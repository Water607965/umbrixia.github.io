<!DOCTYPE html>
<html lang="en">
<head>

    <div id="loadingScreen" class="loading-screen">
    <div class="glitch-text" data-text="Loading Umbrixia...">Loading Umbrixia...</div>
    <p class="loading-dots">Please Wait</p>
       <p class="loading-dots">"Live your life as an exclamation rather than an explanation." - Isaac Newton.</p> 
</div>

    

    <!-- Favicon for Browsers -->
<link rel="icon" href="logo.png" sizes="32x32" type="image/png">
<link rel="icon" href="logo.png" sizes="48x48" type="image/png">
<link rel="icon" href="logo.png" sizes="96x96" type="image/png">

<!-- High-Resolution Icon for Large Displays -->
<link rel="icon" href="logo.png" sizes="512x512" type="image/png">

<!-- Apple Touch Icon for iOS -->
<link rel="apple-touch-icon" href="logo.png" sizes="180x180">

<!-- Microsoft Tile Icon -->
<meta name="msapplication-TileImage" content="logo.png">
<meta name="msapplication-TileColor" content="#000000">

<!-- Open Graph for Social Media -->
<meta property="og:image" content="logo.png">
<meta property="og:image:type" content="image/png">
<meta property="og:image:width" content="512">
<meta property="og:image:height" content="512">
<meta property="og:title" content="Umbrixia - Quantum Elegance">
<meta property="og:description" content="Explore quantum physics with cutting-edge interactivity and depth.">

<!-- Browser Theme Colors -->
<meta name="theme-color" content="#000000">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">



    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Explore quantum physics with advanced interactivity and detailed chapters.">
    <title>Umbrixia</title>
    <link rel="icon" href="logo.png" sizes="48x48" type="image/png">
    <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* General Styling */
        body {
            font-family: 'Raleway', sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #000, #1a1a1a);
            color: #ffd700;
        }

        /* Navbar Styling */
        .navbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 2rem;
            background-color: #000;
            border-bottom: 1px solid #444;
        }

        .navbar img {
            height: 50px;
            margin-right: 1rem;
        }

        .navbar h1 {
            font-size: 2rem;
            color: #ffd700;
        }

        .navbar-links a {
            text-decoration: none;
            color: #ffd700;
            font-weight: bold;
            margin-left: 2rem;
            transition: color 0.3s;
        }

        .navbar-links a:hover {
            color: #ff0000;
        }

        /* Hero Section */
        .hero {
            text-align: center;
            padding: 6rem 2rem;
            background: linear-gradient(to right, #ff0000, #ffd700);
            color: black;
        }

        .hero h2 {
            font-size: 4rem;
            font-weight: bold;
        }

        .hero p {
            font-size: 1.5rem;
            margin-top: 1rem;
        }

        /* Chapters Section */
        .chapters {
            padding: 4rem 2rem;
            background: #111;
        }

        .chapters h3 {
            font-size: 2.5rem;
            text-align: center;
            margin-bottom: 2rem;
            color: #ffd700;
        }

        .chapters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
        }

        .chapter-card {
            background: #222;
            border-radius: 10px;
            padding: 1.5rem;
            text-align: center;
            border: 1px solid #ff0000;
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .chapter-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 4px 15px #ff0000;
        }

        .gold-button {
            background: #ffd700;
            color: black;
            font-weight: bold;
            border: none;
            border-radius: 5px;
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: background 0.3s, transform 0.3s;
        }

        .gold-button:hover {
            background: #ff0000;
            transform: scale(1.1);
        }

        .hidden {
            display: none;
        }

        /* Interactive Section */
        .interactives {
            padding: 4rem 2rem;
            background: #111;
        }

        .interactives h3 {
            font-size: 2.5rem;
            text-align: center;
            margin-bottom: 2rem;
            color: #ffd700;
        }

        .interactives-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
        }

        .interactive-card {
            background: #222;
            border-radius: 10px;
            padding: 1.5rem;
            text-align: center;
            border: 1px solid #ff0000;
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .interactive-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 4px 15px #ff0000;
        }

        /* Footer */
        .footer {
            text-align: center;
            padding: 2rem 0;
            background: #000;
            color: #ffd700;
        }
  
}

.spinner {
    width: 60px;
    height: 60px;
    border: 6px solid rgba(255, 215, 0, 0.3);
    border-top-color: #ffd700;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: 1rem;
}

@keyframes spin {
    from {
        transform: rotate(0deg);
    }
    to {
        transform: rotate(360deg);
    }
}
        .typing {
    display: inline-block;
    white-space: nowrap;
    overflow: hidden;
    border-right: 2px solid #00ff00; /* Blinking cursor effect */
    font-family: "Raleway", sans-serif;
    color: #ffffff;
    font-size: 1.5rem;
    animation: blinkCursor 0.5s infinite;
}

@keyframes blinkCursor {
    50% { border-color: transparent; }
}

        @keyframes typing {
    from { width: 0; }
    to { width: 100%; }
}

@keyframes blinkCursor {
    50% { border-color: transparent; }
}



        /* Fullscreen loading overlay */
.loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: black;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    color: #00ff00;
    font-family: "Courier New", monospace;
    font-size: 2rem;
    z-index: 9999;
    overflow: hidden;
}

/* Glitchy text effect */
.glitch-text {
    position: relative;
    text-transform: uppercase;
    font-size: 4rem;
    font-weight: bold;
    letter-spacing: 3px;
    animation: glitchEffect 1s infinite;
}

/* Creating RGB glitch effects */
.glitch-text::before,
.glitch-text::after {
    content: attr(data-text);
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
}

.glitch-text::before {
    left: 2px;
    text-shadow: -2px 0 red;
    animation: glitchEffect 0.3s infinite;
}

.glitch-text::after {
    left: -2px;
    text-shadow: 2px 0 blue;
    animation: glitchEffect 0.3s infinite reverse;
}

/* Keyframes for glitching effect */
@keyframes glitchEffect {
    0% { transform: translate(0); }
    20% { transform: translate(-2px, -2px); }
    40% { transform: translate(2px, 2px); }
    60% { transform: translate(-1px, 1px); }
    80% { transform: translate(1px, -1px); }
    100% { transform: translate(0); }
}

/* Loading animation effect */
.loading-dots::after {
    content: "";
    display: inline-block;
    animation: dots 1.5s infinite steps(4);
}

@keyframes dots {
    0% { content: "."; }
    25% { content: ".."; }
    50% { content: "..."; }
    75% { content: "...."; }
}

/* Fade-out animation */
.fade-out {
    animation: fadeOut 1s forwards;
}

@keyframes fadeOut {
    100% { opacity: 0; visibility: hidden; }
}

        .fade-text {
    opacity: 0;
    transform: translateY(20px);
    transition: opacity 1.5s ease-out, transform 1.5s ease-out;
}

.fade-in-visible {
    opacity: 1 !important;
    transform: translateY(0) !important;
}

        .typing-glow {
    font-size: 4rem;
    font-weight: bold;
    color: #ffd700;
    text-shadow: 0px 0px 10px rgba(255, 215, 0, 0.8);
    display: inline-block;
    border-right: 3px solid #ffd700;
    white-space: nowrap;
    overflow: hidden;
    width: 0;
    animation: typing 2s steps(30, end) forwards, glow 1.5s infinite alternate;
}

@keyframes typing {
    from { width: 0; }
    to { width: 100%; }
}

@keyframes glow {
    from { text-shadow: 0px 0px 10px rgba(255, 215, 0, 0.6); }
    to { text-shadow: 0px 0px 20px rgba(255, 215, 0, 1); }
}

        #podcast-section {
    text-align: center;
    padding: 3rem 2rem;
    background: linear-gradient(to right, #111, #222);
    color: #ffd700;
    border-bottom: 2px solid #ff0000;
}

#podcast-section h3 {
    font-size: 2rem;
    font-weight: bold;
    margin-bottom: 1rem;
}

#podcast-section p {
    font-size: 1.2rem;
    margin-bottom: 1.5rem;
    opacity: 0.85;
}

/* Podcast Containers */
.podcast-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
}

/* Apple Podcast Badge */
.podcast-link img {
    width: 280px;
    height: auto;
    transition: transform 0.3s ease-in-out;
}

.podcast-link img:hover {
    transform: scale(1.1);
}

/* Spotify Embed */
.spotify-embed {
    width: 100%;
    max-width: 360px;
    height: 152px;
    border-radius: 12px;
    transition: transform 0.3s ease-in-out;
}

.spotify-embed:hover {
    transform: scale(1.05);
}



    </style>
</head>
<body>
    <!-- Navbar -->
    <nav class="navbar">
        <div class="flex">
            <img src="logo.png" alt="Umbrixia Logo">
            <h1>Umbrixia</h1>
        </div>
        <div class="navbar-links">
            <a href="index.html">Home</a>
            <a href="research.html">Research</a>
            <a href="resources.html">Resources</a>
            <a href="community.html">Community</a>
            <a href="contact.html">Contact</a> <!-- Added Contact Us link -->
        </div>
    </nav>

    <!-- Hero Section -->
    <header class="hero">
    
        <header class="hero">
    <h2 class="typing-glow">Welcome to Umbrixia</h2>
    <p class="fade-text">Explore the mysteries of quantum physics.</p>
</header>


    <h2 id="typingText" class="typing-container" data-text="Quantum Physics At It's Finest!"></h2>
        <script>
    function typeEffect(element, text, speed, callback) {
        let i = 0;
        function type() {
            if (i < text.length) {
                element.innerHTML += text.charAt(i);
                i++;
                setTimeout(type, speed);
            } else {
                element.style.borderRight = "none"; // Remove cursor after typing
                if (callback) callback();
            }
        }
        type();
    }

    function startTypingEffect() {
        const typingElement = document.getElementById("typingText");
        if (!typingElement) return;

        const textContent = typingElement.getAttribute("data-text");
        typingElement.innerHTML = ""; // Clear text for typing effect

        typeEffect(typingElement, textContent, 80, () => {
            typingElement.classList.add("glitch"); // Add glitch effect after typing
        });
    }

    document.addEventListener("DOMContentLoaded", startTypingEffect);

            /* Expanded About Section */

</script>

</header>

     



        
</header>

    <section id="podcast-section">
    <h3>🎙️ Explore Quantum Physics with Umbrixia</h3>
    <p>Listen to our podcasts!</p>

    <div class="podcast-container">
        <!-- Apple Podcasts Badge -->
        <iframe height="450" width="100%" title="Media player" src="https://embed.podcasts.apple.com/us/podcast/quantum-physics-through-umbrixia/id1796713977?itscg=30200&amp;itsct=podcast_box_player&amp;ls=1&amp;mttnsubad=1796713977&amp;theme=dark" id="embedPlayer" style="border: 0px; border-radius: 12px; width: 100%; height: 450px; max-width: 650px; --darkreader-inline-border-top: 0px; --darkreader-inline-border-right: 0px; --darkreader-inline-border-bottom: 0px; --darkreader-inline-border-left: 0px;" sandbox="allow-forms allow-popups allow-same-origin allow-scripts allow-top-navigation-by-user-activation" allow="autoplay *; encrypted-media *; clipboard-write" data-darkreader-inline-border-top="" data-darkreader-inline-border-right="" data-darkreader-inline-border-bottom="" data-darkreader-inline-border-left=""></iframe>
        </a>

        <!-- Spotify Podcast Embed -->
        <iframe class="spotify-embed"
                src="https://open.spotify.com/embed/show/7EPiByiBobkSeJ79CrxfLF?utm_source=generator" 
                frameBorder="0" allowfullscreen=""
                allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" 
                loading="lazy">
        </iframe>
    </div>
</section>



   <section class="chapters">
    <h3>Quantum Concepts Simplified</h3>
    <div class="chapters-grid">
        <!-- Chapter 1 -->
        <div class="chapter-card">
            <h4>Chapter 1: Uncertainty</h4>
            <p>Discover the limits of measurement with the Heisenberg Uncertainty Principle.</p>
            <a href="chapter1.html" class="gold-button">Learn More</a>
            <div id="chapter1" class="hidden">
                <p>Explore the uncertainty principle's interconnecting and unifying framework.</p>
            </div>
        </div>

        <!-- Chapter 2 -->
        <div class="chapter-card">
            <h4>Chapter 2: Superposition</h4>
            <p>Learn how particles exist in multiple states simultaneously until observed.</p>
            <a href="chapter2.html" class="gold-button">Learn More</a>
            <div id="chapter2" class="hidden">
                <p>Quantum superposition is foundational to quantum computing and our understanding of quantum mechanics.</p>
            </div>
        </div>

        <!-- Chapter 3 -->
        <div class="chapter-card">
            <h4>Chapter 3: Entanglement</h4>
            <p>Understand the strange connection between particles across vast distances.</p>
            <a href="chapter3.html" class="gold-button">Learn More</a>
            <div id="chapter3" class="hidden">
                <p>Entangled particles remain interconnected no matter how far apart they are.</p>
            </div>
        </div>

        <!-- Chapter 4 -->
        <div class="chapter-card">
            <h4>Chapter 4: Quantum Tunneling</h4>
            <p>Understand how particles traverse potential barriers that they classically shouldn't.</p>
            <a href="chapter4.html" class="gold-button">Learn More</a>
            <div id="chapter4" class="hidden">
                <p>Quantum tunneling explains phenomena like nuclear fusion in stars and electron tunneling in semiconductors.</p>
            </div>
        </div>

        <!-- Chapter 5 -->
        <div class="chapter-card">
            <h4>Chapter 5: Quantum Entanglement</h4>
            <p>Explore the mysterious interconnectedness of particles over vast distances.</p>
            <a href="chapter5.html" class="gold-button">Learn More</a>
            <div id="chapter5" class="hidden">
                <p>Quantum entanglement defies classical intuitions and plays a key role in quantum cryptography and quantum computing.</p>
            </div>
        </div>

        <!-- Chapter 6 -->
        <div class="chapter-card">
            <h4>Chapter 6: Quantum Decoherence</h4>
            <p>Quantum decoherence explains why macroscopic objects don't exhibit quantum superposition, linking quantum to classical worlds.</p>
            <h5>Click the button down below to initiate.</h5>
            <a href="chapter6.html" class="gold-button">Learn More</a>
            <div id="chapter6" class="hidden">
            </div>
        </div>

        <!-- Chapter 7 -->
        <div class="chapter-card">
            <h4>Chapter 7: Quantum Probability</h4>
            <p>Understand how probabilities govern the behavior of quantum systems.</p>
            <a href="chapter7.html" class="gold-button">Learn More</a>
            <div id="chapter7" class="hidden">
                <p>Probability densities help us predict where particles are most likely to be found in quantum systems.</p>
            </div>
        </div>

        <!-- Chapter 8 -->
        <div class="chapter-card">
            <h4>Chapter 8: Quantum Measurement</h4>
            <p>Explore how measurement collapses quantum states into classical outcomes.</p>
            <a href="chapter8.html" class="gold-button">Learn More</a>
            <div id="chapter8" class="hidden">
                <p>Measurement in quantum physics involves the collapse of wave functions and introduces the observer effect.</p>
            </div>
        </div>

        <!-- Chapter 9 -->
        <div class="chapter-card">
            <h4>Chapter 9: Quantum Field Theory</h4>
            <p>Dive into the advanced realm of quantum fields that underpin all of physics.</p>
            <a href="chapter9.html" class="gold-button">Learn More</a>
            <div id="chapter9" class="hidden">
                <p>Quantum field theory unifies quantum mechanics and special relativity, describing particles as excitations in fields.</p>
            </div>
        </div>
    </div>
</section>

<section class="interactives">
    <h3>Interactive Quantum Concepts</h3>
    <div class="interactives-grid">
        <!-- Wave-Particle Duality -->
        <div class="interactive-card">
            <h4>Wave-Particle Duality</h4>
            <canvas id="waveParticleCanvas" width="400" height="200"></canvas>
            <button class="gold-button" onclick="toggleWaveParticleMode()">Toggle Mode</button>
        </div>

        <!-- Double-Slit Experiment -->
        <div class="interactive-card">
            <h4>Double-Slit Experiment</h4>
            <canvas id="doubleSlitCanvas" width="400" height="200"></canvas>
            <button class="gold-button" onclick="toggleObserverMode()">Toggle Observer</button>
        </div>

        <!-- Schrödinger's Cat -->
        <div class="interactive-card">
            <h4>Schrödinger's Cat</h4>
            <canvas id="catCanvas" width="400" height="200"></canvas>
            <button class="gold-button" onclick="toggleObservation()">Toggle State</button>
        </div>

        <!-- Quantum Entanglement -->
        <div class="interactive-card">
            <h4>Quantum Entanglement</h4>
            <canvas id="entanglementCanvas" width="400" height="200"></canvas>
            <button class="gold-button" onclick="toggleEntanglement()">Toggle Entanglement</button>
        </div>

        <!-- Quantum Tunneling -->
        <div class="interactive-card">
            <h4>Quantum Tunneling</h4>
            <canvas id="tunnelingCanvas" width="400" height="200"></canvas>
            <button class="gold-button" onclick="toggleTunneling()">Toggle Tunneling</button>
        </div>

        <!-- Quantum Superposition -->
        <div class="interactive-card">
            <h4>Quantum Superposition</h4>
            <h5>Click the button down below to initiate.</h5>
            <canvas id="superpositionCanvas" width="400" height="200"></canvas>
            <button class="gold-button" onclick="toggleSuperposition()">Toggle State</button>
        </div>

        <!-- Quantum Decoherence -->
        <div class="interactive-card">
            <h4>Quantum Decoherence</h4>
            <h5>Click the button down below to initiate.</h5>
            <canvas id="decoherenceCanvas" width="400" height="200"></canvas>
            <button class="gold-button" onclick="startDecoherence()">Start Decoherence</button>
        </div>

        <!-- Quantum Probability Density -->
        <div class="interactive-card">
            <h4>Quantum Probability Density</h4>
            <h5>Click the button down below to initiate.</h5>
            <canvas id="probabilityDensityCanvas" width="400" height="200"></canvas>
            <button class="gold-button" onclick="updateDensity()">Update Density</button>
        </div>
        
        <div class="interactive-card">
    <h4>Quantum Vacuum Fluctuations</h4>
            <h5>Click the button down below to initiate.</h5>
    <canvas id="vacuumFluctuationsCanvas" width="400" height="200"></canvas>
    <button class="gold-button" onclick="toggleVacuumFluctuations()">Toggle Fluctuations</button>
        </div>

        <div class="interactive-card">
    <h4>Quantum Harmonic Oscillator</h4>
            <h5>Click the button down below to initiate.</h5>
    <canvas id="harmonicOscillatorCanvas" width="400" height="200"></canvas>
    <button class="gold-button" onclick="toggleHarmonicOscillation()">Toggle Oscillation</button>
        </div>

        <div class="interactive-card">
    <h4>Quantum Phase Shift</h4>
            <h5>Click the button down below to initiate. Spamming is encouraged.</h5>
    <canvas id="phaseShiftCanvas" width="400" height="200"></canvas>
    <button class="gold-button" onclick="changePhase()">Change Phase</button>
        </div>

        <div class="interactive-card">
    <h4>Quantum Energy Levels</h4>
            <h5>Click the button down below to initiate.</h5>
    <canvas id="energyLevelsCanvas" width="400" height="200"></canvas>
    <button class="gold-button" onclick="addEnergyLevel()">Add Energy Level</button>
        </div>

        <div class="interactive-card">
    <h4>Particle Decay</h4>
            <h5>Click the button down below to initiate. Spamming is encouraged.</h5>
    <canvas id="particleDecayCanvas" width="400" height="200"></canvas>
    <button class="gold-button" onclick="resetDecay()">Reset Decay</button>
        </div>
        
        <div class="interactive-card">
    <h4>Quantum Time Evolution</h4>
    <canvas id="timeEvolutionCanvas" width="400" height="200"></canvas>
        </div>

        <div class="interactive-card">
    <h4>Quantum Spin Simulation</h4>
    <canvas id="spinCanvas" width="400" height="200"></canvas>
    <button class="gold-button" onclick="flipSpin()">Flip Spin</button>
        </div>

        <div class="interactive-card">
    <h4>Quantum Probability Clouds</h4>
    <canvas id="probabilityCloudCanvas" width="400" height="200"></canvas>
        </div>

        <div class="interactive-card">
    <h4>Quantum Uncertainty</h4>
    <canvas id="uncertaintyCanvas" width="400" height="200"></canvas>
    <button class="gold-button" onclick="increaseMomentum()">Increase Momentum Precision</button>
        </div>

        <div class="interactive-card">
    <h4>Quantum Wave Collapse</h4>
    <canvas id="waveCollapseCanvas" width="400" height="200"></canvas>
    <button class="gold-button" onclick="collapseWave()">Measure System</button>
        </div>

        <div class="interactive-card">
    <h4>Quantum Time Reversal</h4>
    <canvas id="timeReversalCanvas" width="400" height="200"></canvas>
    <button class="gold-button" onclick="reverseTime()">Reverse Time</button>
        </div>

        <div class="interactive-card">
    <h4>Quantum Eraser</h4>
    <canvas id="eraserCanvas" width="400" height="200"></canvas>
    <button class="gold-button" onclick="erasePath()">Erase Path</button>
        </div>

        <div class="interactive-card">
    <h4>Quantum Superdeterminism</h4>
    <canvas id="superdeterminismCanvas" width="400" height="200"></canvas>
    <button class="gold-button" onclick="changeOutcome()">Change Outcome</button>
        </div>

        <div class="interactive-card">
    <h4>Quantum Virtual Particles</h4>
    <canvas id="virtualParticlesCanvas" width="400" height="200"></canvas>
        </div>

        <div class="interactive-card">
    <h4>Quantum Multiverse Split</h4>
    <canvas id="multiverseSplitCanvas" width="400" height="200"></canvas>
    <button class="gold-button" onclick="splitMultiverse()">Split Reality</button>
        </div>

        <!-- Quantum Eraser Experiment -->
        <div class="interactive-card">
    <h4>Quantum Eraser Experiment</h4>
    <canvas id="quantumEraserCanvas" width="400" height="200"></canvas>
    <button class="gold-button" onclick="toggleQuantumEraser()">Toggle Observer</button>
        </div>

<!-- Quantum Wormhole Simulator -->
        <div class="interactive-card">
    <h4>Quantum Wormhole Simulator</h4>
            <h5>Hover your cursor in the blank space.</h5>
    <canvas id="wormholeCanvas" width="400" height="200"></canvas>
        </div>

<!-- Quantum Fractal Generator -->
        <div class="interactive-card">
    <h4>Quantum Fractal Generator</h4>
            <h5>Observe...</h5>
    <canvas id="fractalCanvas" width="400" height="200"></canvas>
    <button class="gold-button" onclick="generateFractal()">Generate</button>
        </div>

<!-- Quantum Energy Field Distortion -->
        <div class="interactive-card">
    <h4>Quantum Energy Field Distortion</h4>
            <h5>Move cursor across to beam and project particles.</h5>
    <canvas id="energyFieldCanvas" width="400" height="200"></canvas>
        </div>

<!-- Quantum Gravity Well -->
        <div class="interactive-card">
    <h4>Quantum Gravity Well</h4>
            <h5>Click in black holl to drop objects into the darkness. Spamming is encouraged.</h5>
    <canvas id="gravityWellCanvas" width="400" height="200"></canvas>
        </div>

        <!-- Quantum Time Distortion 
        <div class="interactive-card">
    <h4>Quantum Time Distortion</h4>
    <canvas id="timeDistortionCanvas" width="400" height="200"></canvas>
    <input type="range" id="timeSpeed" min="-3" max="3" step="0.1" value="1">
        </div> -->



        
    
        <div class="interactive-card">
            <h4>Quantum Time Distortion</h4>
            <canvas id="timeDistortionCanvas" width="400" height="200"></canvas>
            <input type="range" id="timeSpeed" min="-3" max="3" step="0.1" value="1">
        </div>

        

        

        <div class="interactive-card">
            <h4>Quantum Wormhole Generator</h4>
            <canvas id="wormholeCanvas" width="400" height="200"></canvas>
        </div>
        

        <div class="interactive-card">
            <h4>Quantum Reality Splitter</h4>
            <canvas id="realitySplitterCanvas" width="400" height="200"></canvas>
        </div>
        

        <div class="interactive-card">
            <h4>Subatomic Chaos Engine</h4>
            <canvas id="chaosCanvas" width="400" height="200"></canvas>
        </div>

        <div class="interactive-card">
            <h4>Gravity Well Simulation</h4>
            <canvas id="gravityWellCanvas" width="400" height="200"></canvas>
        </div>
        

        

        <div class="interactive-card">
            <h4>Spacetime Ripple Engine</h4>
            <canvas id="spacetimeRippleCanvas" width="400" height="200"></canvas>
        </div>

        <div class="interactive-card">
            <h4>Dark Matter Field</h4>
            <canvas id="darkMatterFieldCanvas" width="400" height="200"></canvas>
        </div>

        <div class="interactive-card">
            <h4>Quantum Flux</h4>
            <canvas id="quantumFluxCanvas" width="400" height="200"></canvas>
        </div>

        <div class="interactive-card">
            <h4>Hypercube Portal</h4>
            <canvas id="hypercubePortalCanvas" width="400" height="200"></canvas>
        </div>

        <div class="interactive-card">
            <h4>Quantum Storm</h4>
            <canvas id="quantumStormCanvas" width="400" height="200"></canvas>
        </div>

        <!-- Extra Quantum Experiments -->

  
    <!-- Quantum Entropy Cascade -->
    <div class="interactive-card">
      <h4>Quantum Entropy Cascade</h4>
      <canvas id="entropyCascadeCanvas" width="400" height="200"></canvas>
      <button class="gold-button" onclick="triggerEntropyCascade()">Trigger Cascade</button>
    </div>

    <!-- Quantum String Symphony -->
    <div class="interactive-card">
      <h4>Quantum String Symphony</h4>
      <canvas id="stringSymphonyCanvas" width="400" height="200"></canvas>
      <button class="gold-button" onclick="startStringSymphony()">Harmonize Strings</button>
    </div>

    <!-- Quantum Random Walk -->
    <div class="interactive-card">
      <h4>Quantum Random Walk</h4>
      <canvas id="randomWalkCanvas" width="400" height="200"></canvas>
      <button class="gold-button" onclick="startRandomWalk()">Start Walk</button>
    </div>

    <!-- Quantum Phase Transition -->
    <div class="interactive-card">
      <h4>Quantum Phase Transition</h4>
      <canvas id="phaseTransitionCanvas" width="400" height="200"></canvas>
      <button class="gold-button" onclick="triggerPhaseTransition()">Trigger Transition</button>
    </div>

    <!-- Quantum Bubble Collapse -->
    <div class="interactive-card">
      <h4>Quantum Bubble Collapse</h4>
      <canvas id="bubbleCollapseCanvas" width="400" height="200"></canvas>
      <button class="gold-button" onclick="collapseBubble()">Collapse Bubble</button>
    </div>

        <div class="interactive-card">
      <h4>Quantum Particle Accelerator</h4>
      <canvas id="acceleratorCanvas" width="400" height="200"></canvas>
      <div style="margin-top: 0.5rem;">
        <button class="gold-button" onclick="Accelerator.launchParticle()">Launch Particle</button>
        <button class="gold-button" onclick="Accelerator.reset()">Reset Accelerator</button>
      </div>
    </div>

    <!-- Entangled Particle Dance -->
    <div class="interactive-card">
      <h4>Entangled Particle Dance</h4>
      <canvas id="entangledDanceCanvas" width="400" height="200"></canvas>
      <button class="gold-button" onclick="EntangledDance.toggle()">Toggle Dance</button>
    </div>

    <!-- Chaotic Quantum Collider -->
    <div class="interactive-card">
      <h4>Chaotic Quantum Collider</h4>
      <canvas id="colliderCanvas" width="400" height="200"></canvas>
      <button class="gold-button" onclick="Collider.addParticle()">Add Particle</button>
    </div>

    <!-- Quantum Field Oscillation -->
    <div class="interactive-card">
      <h4>Quantum Field Oscillation</h4>
      <canvas id="fieldOscillationCanvas" width="400" height="200"></canvas>
      <div style="display: flex; justify-content: center; gap: 1rem; margin-top: 0.5rem;">
        <input type="range" id="fieldAmplitude" min="10" max="100" value="50" title="Amplitude">
        <input type="range" id="fieldFrequency" min="0.01" max="0.2" step="0.01" value="0.05" title="Frequency">
      </div>
      <button class="gold-button" onclick="FieldOscillation.update()">Update Field</button>
    </div>

    <!-- Wormhole Explorer 2.0 -->
    <div class="interactive-card">
      <h4>Wormhole Explorer 2.0</h4>
      <canvas id="wormholeExplorerCanvas" width="400" height="200"></canvas>
      <button class="gold-button" onclick="WormholeExplorer.distort()">Distort Wormhole</button>
    </div>

        <div class="interactive-card">
      <h4>Quantum Neural Network</h4>
      <canvas id="quantumNeuralCanvas" width="400" height="200"></canvas>
      <button class="gold-button" onclick="QuantumNeural.toggle()">Toggle Network</button>
    </div>

    <!-- Multidimensional Quantum Landscape -->
    <div class="interactive-card">
      <h4>Multidimensional Quantum Landscape</h4>
      <canvas id="quantumLandscapeCanvas" width="400" height="200"></canvas>
      <button class="gold-button" onclick="QuantumLandscape.changeView()">Change View</button>
    </div>

    <!-- Quantum Gravity Ripple Simulator -->
    <div class="interactive-card">
      <h4>Quantum Gravity Ripples</h4>
      <canvas id="gravityRippleCanvas" width="400" height="200"></canvas>
      <button class="gold-button" onclick="GravityRipple.disturb()">Disturb Ripples</button>
    </div>

    <!-- Quantum Entanglement Universe -->
    <div class="interactive-card">
      <h4>Quantum Entanglement Universe</h4>
      <canvas id="entanglementUniverseCanvas" width="400" height="200"></canvas>
      <button class="gold-button" onclick="EntanglementUniverse.shuffle()">Shuffle Entanglement</button>
    </div>

    <!-- Spacetime Distortion Portal -->
    <div class="interactive-card">
      <h4>Spacetime Distortion Portal</h4>
      <canvas id="distortionPortalCanvas" width="400" height="200"></canvas>
      <button class="gold-button" onclick="DistortionPortal.warp()">Warp Portal</button>
    </div>

        <!-- Quantum Tunneling Visualizer -->
    <div class="interactive-card">
      <h4>Quantum Tunneling Visualizer</h4>
      <canvas id="tunnelingVisualizerCanvas" width="400" height="200"></canvas>
      <div style="margin-top: 0.5rem;">
        <label style="font-size: 0.9rem; color: #ffd700;">
          Barrier Height:
          <input type="range" id="barrierHeight" min="10" max="100" value="50">
        </label>
        <label style="font-size: 0.9rem; color: #ffd700; margin-left: 1rem;">
          Barrier Width:
          <input type="range" id="barrierWidth" min="20" max="150" value="80">
        </label>
      </div>
      <button class="gold-button" onclick="TunnelingVisualizer.simulate()">Simulate Tunneling</button>
    </div>

    <!-- Wave Function Collapse Simulator -->
    <div class="interactive-card">
      <h4>Wave Function Collapse</h4>
      <canvas id="collapseSimulatorCanvas" width="400" height="200"></canvas>
      <button class="gold-button" onclick="CollapseSimulator.measure()">Measure & Collapse</button>
    </div>

    <!-- Superposition Decision Tree -->
    <div class="interactive-card">
      <h4>Superposition Decision Tree</h4>
      <canvas id="superpositionTreeCanvas" width="400" height="200"></canvas>
      <button class="gold-button" onclick="SuperpositionTree.collapse()">Collapse Superposition</button>
    </div>

    <!-- Decoherence Detector -->
    <div class="interactive-card">
      <h4>Decoherence Detector</h4>
      <canvas id="decoherenceCanvas" width="400" height="200"></canvas>
      <div style="margin-top: 0.5rem; text-align: center;">
        <label style="font-size: 0.9rem; color: #ffd700;">
          Decoherence Level:
          <input type="range" id="decoherenceLevel" min="0" max="1" step="0.01" value="0.0">
        </label>
      </div>
    </div>

    <!-- Quantum Time Machine -->
    <div class="interactive-card">
      <h4>Quantum Time Machine</h4>
      <canvas id="timeMachineCanvas" width="400" height="200"></canvas>
      <div style="margin-top: 0.5rem; text-align: center;">
        <label style="font-size: 0.9rem; color: #ffd700;">
          Time Speed:
          <input type="range" id="timeSpeedControl" min="-3" max="3" step="0.1" value="1">
        </label>
      </div>
  </div>

    <!-- Quantum Multiverse Explorer -->
    <div class="interactive-card">
      <h4>Quantum Multiverse Explorer</h4>
      <canvas id="multiverseCanvas" width="400" height="200"></canvas>
      <button class="gold-button" onclick="Multiverse.split()">Split the Multiverse</button>
    </div>

    <!-- Quantum Entanglement Arena -->
    <div class="interactive-card">
      <h4>Quantum Entanglement Arena</h4>
      <canvas id="entanglementArenaCanvas" width="400" height="200"></canvas>
      <button class="gold-button" onclick="EntanglementArena.battle()">Trigger Battle</button>
    </div>

    <!-- Decoherence Escape Challenge -->
    <div class="interactive-card">
      <h4>Decoherence Escape Challenge</h4>
      <canvas id="decoherenceEscapeCanvas" width="400" height="200"></canvas>
      <button class="gold-button" onclick="DecoherenceEscape.activate()">Resist Decoherence</button>
    </div>

    <!-- Quantum Algorithm Visualizer -->
    <div class="interactive-card">
      <h4>Quantum Algorithm Visualizer</h4>
      <canvas id="algorithmCanvas" width="400" height="200"></canvas>
      <button class="gold-button" onclick="QuantumAlgorithm.run()">Run Algorithm</button>
    </div>

    <!-- Quantum Black Hole Playground -->
    <div class="interactive-card">
      <h4>Quantum Black Hole Playground</h4>
      <canvas id="blackHoleCanvas" width="400" height="200"></canvas>
      <button class="gold-button" onclick="BlackHole.warp()">Warp Space</button>
    </div>

        
    <!-- Quantum Reality Synthesizer -->
    <div class="interactive-card">
      <h4>Quantum Reality Synthesizer</h4>
      <canvas id="realitySynthCanvas" width="400" height="200"></canvas>
      <div style="margin-top: 0.5rem;">
        <label style="color: #ffd700; font-size: 0.9rem;">
          Fractal Depth:
          <input type="range" id="synthDepth" min="1" max="10" step="1" value="5">
        </label>
      </div>
      <button class="gold-button" onclick="RealitySynthesizer.generate()">Generate Synthesis</button>
    </div>

    <!-- Quantum Entropy Reactor -->
    <div class="interactive-card">
      <h4>Quantum Entropy Reactor</h4>
      <canvas id="entropyReactorCanvas" width="400" height="200"></canvas>
      <button class="gold-button" onclick="EntropyReactor.ignite()">Ignite Reactor</button>
    </div>

    <!-- Quantum Field Collider -->
    <div class="interactive-card">
      <h4>Quantum Field Collider</h4>
      <canvas id="fieldColliderCanvas" width="400" height="200"></canvas>
      <button class="gold-button" onclick="FieldCollider.collide()">Collide Fields</button>
    </div>

    <!-- Quantum Superposition Maze -->
    <div class="interactive-card">
      <h4>Quantum Superposition Maze</h4>
      <canvas id="superpositionMazeCanvas" width="400" height="200"></canvas>
      <button class="gold-button" onclick="SuperpositionMaze.start()">Start Maze</button>
    </div>

    <!-- Quantum Wormhole Architect -->
    <div class="interactive-card">
      <h4>Quantum Wormhole Architect</h4>
      <canvas id="wormholeArchitectCanvas" width="400" height="200"></canvas>
      <div style="margin-top: 0.5rem;">
        <label style="color: #ffd700; font-size: 0.9rem;">
          Warp Intensity:
          <input type="range" id="warpIntensity" min="0" max="50" step="1" value="20">
        </label>
      </div>
      <button class="gold-button" onclick="WormholeArchitect.build()">Build Wormhole</button>
    </div>

        </script>
            <canvas id="timeDistortionCanvas" width="400" height="200"></canvas>
<input type="range" id="timeSpeed" min="-3" max="3" step="0.1" value="1">

<canvas id="wormholeCanvas" width="400" height="200"></canvas>
<!--<canvas id="realitySplitterCanvas" width="400" height="200"></canvas>-->
<!--<canvas id="chaosCanvas" width="400" height="200"></canvas>-->
<!--<canvas id="gravityWellCanvas" width="400" height="200"></canvas>-->
                </script>

    </script>
        <canvas id="quantumStormCanvas" width="400" height="200"></canvas>
<!--<canvas id="spacetimeRippleCanvas" width="400" height="200"></canvas>-->
<!--<canvas id="darkMatterFieldCanvas" width="400" height="200"></canvas>-->
<!--<canvas id="quantumFluxCanvas" width="400" height="200"></canvas>-->
<!--<canvas id="hypercubePortalCanvas" width="400" height="200"></canvas>-->
        </script>
        
    </div>
</section>

    <!-- Footer -->
    <footer class="footer">
        <p>&copy; 2025 Umbrixia. All rights reserved.</p>
    </footer>
<script>
    // Helper: Safely get canvas context
    function getCanvasContext(canvasId) {
        const canvas = document.getElementById(canvasId);
        return canvas ? canvas.getContext("2d") : null;
    }

    // Toggle visibility for chapters
    function toggleContent(id) {
        const content = document.getElementById(id);
        if (content) {
            content.classList.toggle("hidden");
        }
    }

    // Wave-Particle Duality Interactive
    (() => {
        const ctx = getCanvasContext("waveParticleCanvas");
        let waveMode = true;

        function drawWave() {
            if (!ctx) return;
            ctx.clearRect(0, 0, 400, 200);
            ctx.strokeStyle = "white";
            for (let x = 0; x < 400; x += 5) {
                const y = 100 + Math.sin((x + Date.now() / 100) * 0.1) * 40;
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fillStyle = "yellow";
                ctx.fill();
            }
        }

        function drawParticle() {
            if (!ctx) return;
            ctx.clearRect(0, 0, 400, 200);
            ctx.fillStyle = "red";
            ctx.beginPath();
            ctx.arc(200, 100, 20, 0, Math.PI * 2);
            ctx.fill();
        }

        function animate() {
            if (waveMode) drawWave();
            else drawParticle();
            requestAnimationFrame(animate);
        }

        window.toggleWaveParticleMode = () => (waveMode = !waveMode);
        animate();
    })();

    // Double-Slit Experiment Interactive
    (() => {
        const ctx = getCanvasContext("doubleSlitCanvas");
        let observerEnabled = false;

        function drawInterference() {
            if (!ctx) return;
            ctx.clearRect(0, 0, 400, 200);
            for (let i = 0; i < 400; i += 10) {
                const intensity = Math.sin(i * 0.1) ** 2 * 255;
                ctx.fillStyle = `rgb(${intensity}, ${intensity}, ${intensity})`;
                ctx.fillRect(i, 0, 10, 200);
            }
        }

        function drawParticles() {
            if (!ctx) return;
            ctx.clearRect(0, 0, 400, 200);
            ctx.fillStyle = "blue";
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * 400;
                const y = Math.random() * 200;
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function animate() {
            if (observerEnabled) drawParticles();
            else drawInterference();
            requestAnimationFrame(animate);
        }

        window.toggleObserverMode = () => (observerEnabled = !observerEnabled);
        animate();
    })();

    // Schrödinger's Cat Interactive
    (() => {
        const ctx = getCanvasContext("catCanvas");
        let catState = "Superposition";

        function drawCatState() {
            if (!ctx) return;
            ctx.clearRect(0, 0, 400, 200);
            ctx.fillStyle = "black";
            ctx.fillRect(0, 0, 400, 200);

            ctx.fillStyle = catState === "Alive" ? "green" : catState === "Dead" ? "red" : "yellow";
            ctx.beginPath();
            ctx.arc(200, 100, 50, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = "white";
            ctx.font = "20px Arial";
            ctx.fillText(`State: ${catState}`, 140, 180);
        }

        window.toggleObservation = () => {
            catState = catState === "Superposition" ? (Math.random() > 0.5 ? "Alive" : "Dead") : "Superposition";
            drawCatState();
        };

        drawCatState();
    })();

    // Quantum Vacuum Fluctuations Interactive
    (() => {
        const ctx = getCanvasContext("vacuumFluctuationsCanvas");
        let fluctuating = false;

        function drawFluctuations() {
            if (!ctx) return;
            ctx.clearRect(0, 0, 400, 200);
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * 400;
                const y = Math.random() * 200;
                const radius = Math.random() * 5;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255}, 0.8)`;
                ctx.fill();
            }
            if (fluctuating) requestAnimationFrame(drawFluctuations);
        }

        window.toggleVacuumFluctuations = () => {
            fluctuating = !fluctuating;
            if (fluctuating) drawFluctuations();
        };
    })();

    // Quantum Harmonic Oscillator Interactive
    (() => {
        const ctx = getCanvasContext("harmonicOscillatorCanvas");
        let oscillating = false;

        function drawOscillation() {
            if (!ctx) return;
            ctx.clearRect(0, 0, 400, 200);
            ctx.strokeStyle = "blue";
            for (let i = 0; i < 400; i++) {
                const y = 100 + Math.sin((i + Date.now() / 100) * 0.1) * 40;
                ctx.beginPath();
                ctx.arc(i, y, 1, 0, Math.PI * 2);
                ctx.stroke();
            }
            if (oscillating) requestAnimationFrame(drawOscillation);
        }

        window.toggleHarmonicOscillation = () => {
            oscillating = !oscillating;
            if (oscillating) drawOscillation();
        };
    })();

    // Quantum Phase Shift Interactive
    (() => {
        const ctx = getCanvasContext("phaseShiftCanvas");
        let phase = 0;

        function drawPhaseShift() {
            if (!ctx) return;
            ctx.clearRect(0, 0, 400, 200);
            ctx.strokeStyle = "cyan";
            for (let x = 0; x < 400; x += 5) {
                const y = 100 + Math.sin((x + phase) * 0.1) * 50;
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2);
                ctx.stroke();
            }
            phase += Math.PI / 20;
        }

        window.changePhase = () => drawPhaseShift();
    })();

    // Quantum Energy Levels Interactive
    (() => {
        const ctx = getCanvasContext("energyLevelsCanvas");

        function drawEnergyLevels() {
            if (!ctx) return;
            ctx.clearRect(0, 0, 400, 200);
            for (let i = 1; i <= 5; i++) {
                const y = 200 - i * 30;
                ctx.beginPath();
                ctx.moveTo(50, y);
                ctx.lineTo(350, y);
                ctx.strokeStyle = `rgba(${i * 50}, ${255 - i * 50}, 100, 1)`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        window.addEnergyLevel = () => drawEnergyLevels();
    })();

    // Particle Decay Interactive
    (() => {
        const ctx = getCanvasContext("particleDecayCanvas");
        let particles = [];

        function initParticles() {
            particles = Array.from({ length: 50 }, () => ({
                x: 200,
                y: 100,
                vx: (Math.random() - 0.5) * 5,
                vy: (Math.random() - 0.5) * 5,
                life: Math.random() * 100 + 50,
            }));
        }

        function drawDecay() {
            if (!ctx || particles.length === 0) return;
            ctx.clearRect(0, 0, 400, 200);
            particles.forEach((p) => {
                if (p.life > 0) {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life--;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 0, 0, ${p.life / 100})`;
                    ctx.fill();
                }
            });
            particles = particles.filter((p) => p.life > 0);
            if (particles.length > 0) requestAnimationFrame(drawDecay);
        }

        window.resetDecay = () => {
            initParticles();
            drawDecay();
        };

        initParticles();
    })();

    // Quantum Superposition Interactive
    (() => {
        const ctx = getCanvasContext("superpositionCanvas");

        function drawSuperpositionState() {
            if (!ctx) return;
            ctx.clearRect(0, 0, 400, 200);
            ctx.fillStyle = "purple";
            ctx.fillText("Quantum Superposition State", 50, 100);
        }

        window.toggleSuperposition = () => drawSuperpositionState();
    })();

    // Quantum Decoherence Interactive
    (() => {
        const ctx = getCanvasContext("decoherenceCanvas");

        function drawDecoherence() {
            if (!ctx) return;
            ctx.clearRect(0, 0, 400, 200);
            ctx.strokeStyle = "lime";
            for (let i = 0; i < 400; i += 20) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(200, 200);
                ctx.stroke();
            }
        }

        window.startDecoherence = () => drawDecoherence();
    })();

    // Quantum Probability Density Interactive
    (() => {
        const ctx = getCanvasContext("probabilityDensityCanvas");

        function drawProbabilityDensity() {
            if (!ctx) return;
            ctx.clearRect(0, 0, 400, 200);
            ctx.fillStyle = "rgba(255, 215, 0, 0.7)";
            for (let i = 0; i < 20; i++) {
                const x = Math.random() * 400;
                const y = Math.random() * 200;
                ctx.beginPath();
                ctx.arc(x, y, Math.random() * 15, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        window.updateDensity = () => drawProbabilityDensity();
    })();
        // Quantum Entanglement Interactive
(() => {
    const ctx = getCanvasContext("entanglementCanvas");
    let entanglementState = true;

    function drawEntanglement() {
        if (!ctx) return;
        ctx.clearRect(0, 0, 400, 200);

        ctx.strokeStyle = entanglementState ? "blue" : "green";
        ctx.lineWidth = 2;

        for (let i = 0; i < 5; i++) {
            ctx.beginPath();
            ctx.moveTo(50 + i * 60, 50);
            ctx.lineTo(100 + i * 60, 150);
            ctx.stroke();
        }

        ctx.font = "18px Arial";
        ctx.fillStyle = "white";
        ctx.fillText(entanglementState ? "Entangled" : "Not Entangled", 150, 180);
    }

    window.toggleEntanglement = () => {
        entanglementState = !entanglementState;
        drawEntanglement();
    };

    // Draw immediately on page load
    drawEntanglement();
})();

// Quantum Tunneling Interactive
(() => {
    const ctx = getCanvasContext("tunnelingCanvas");
    let tunnelingActive = false;

    function drawTunneling() {
        if (!ctx) return;
        ctx.clearRect(0, 0, 400, 200);

        // Barrier
        ctx.fillStyle = "gray";
        ctx.fillRect(150, 50, 100, 100);

        // Particle before barrier
        ctx.fillStyle = tunnelingActive ? "yellow" : "red";
        ctx.beginPath();
        ctx.arc(100, 100, 20, 0, Math.PI * 2);
        ctx.fill();

        // Particle after barrier (if tunneling active)
        if (tunnelingActive) {
            ctx.beginPath();
            ctx.arc(300, 100, 20, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.font = "18px Arial";
        ctx.fillStyle = "white";
        ctx.fillText(tunnelingActive ? "Tunneled" : "Not Tunneled", 140, 180);
    }

    window.toggleTunneling = () => {
        tunnelingActive = !tunnelingActive;
        drawTunneling();
    };

    // Draw immediately on page load
    drawTunneling();
})();

</script>

    <script>
    document.addEventListener("DOMContentLoaded", () => {
        setTimeout(() => {
            document.getElementById("loadingScreen").classList.add("fade-out");
        }, 2000);
    });
</script>

    <script>
        document.addEventListener("DOMContentLoaded", () => {
    function typeText(element, text, speed = 50) {
        let index = 0;
        function type() {
            if (index < text.length) {
                element.innerHTML += text.charAt(index);
                index++;
                setTimeout(type, speed + Math.random() * 50); // Randomized speed
            }
        }
        element.innerHTML = ""; // Clear text before typing
        type();
    }

    function fadeInOnScroll() {
        document.querySelectorAll('.fade-text').forEach(section => {
            const sectionTop = section.getBoundingClientRect().top;
            if (sectionTop < window.innerHeight - 100) {
                section.classList.add('fade-in-visible');
            }
        });
    }

    document.querySelectorAll('.fade-text').forEach(el => {
        const fullText = el.innerText;
        el.innerText = ""; // Clear initial text
        typeText(el, fullText);
    });

    window.addEventListener('scroll', fadeInOnScroll);
    fadeInOnScroll();
});
        (() => {
    const ctx = getCanvasContext("timeEvolutionCanvas");
    let time = 0;

    function drawWavePacket() {
        if (!ctx) return;
        ctx.clearRect(0, 0, 400, 200);
        ctx.strokeStyle = "cyan";
        ctx.lineWidth = 2;

        ctx.beginPath();
        for (let x = 0; x < 400; x++) {
            let y = 100 + Math.sin((x + time) * 0.05) * Math.exp(-0.005 * Math.pow(x - 200, 2)) * 50;
            ctx.lineTo(x, y);
        }
        ctx.stroke();

        time += 1.5;
        requestAnimationFrame(drawWavePacket);
    }

    drawWavePacket();
})();


        (() => {
    const ctx = getCanvasContext("spinCanvas");
    let spinState = "Up";

    function drawSpin() {
        if (!ctx) return;
        ctx.clearRect(0, 0, 400, 200);
        ctx.fillStyle = spinState === "Up" ? "blue" : "red";
        
        ctx.beginPath();
        ctx.arc(200, 100, 50, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "white";
        ctx.font = "20px Arial";
        ctx.fillText(`Spin: ${spinState}`, 150, 180);
    }

    window.flipSpin = () => {
        spinState = Math.random() > 0.5 ? "Up" : "Down";
        drawSpin();
    };

    drawSpin();
})();

        (() => {
    const ctx = getCanvasContext("probabilityCloudCanvas");

    function drawProbabilityCloud() {
        if (!ctx) return;
        ctx.clearRect(0, 0, 400, 200);
        ctx.fillStyle = "rgba(255, 215, 0, 0.5)";
        
        for (let i = 0; i < 100; i++) {
            let r = Math.random() * 50;
            let theta = Math.random() * Math.PI * 2;
            let x = 200 + r * Math.cos(theta);
            let y = 100 + r * Math.sin(theta);
            ctx.beginPath();
            ctx.arc(x, y, Math.random() * 5, 0, Math.PI * 2);
            ctx.fill();
        }

        requestAnimationFrame(drawProbabilityCloud);
    }

    drawProbabilityCloud();
})();


        (() => {
    const ctx = getCanvasContext("uncertaintyCanvas");
    let momentumPrecision = 1;

    function drawUncertainty() {
        if (!ctx) return;
        ctx.clearRect(0, 0, 400, 200);
        ctx.strokeStyle = "yellow";
        ctx.lineWidth = 2;

        for (let x = 0; x < 400; x += 10) {
            let y = 100 + Math.sin(x * 0.1) * (50 / momentumPrecision);
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, Math.PI * 2);
            ctx.stroke();
        }
    }

    window.increaseMomentum = () => {
        momentumPrecision *= 1.2;
        drawUncertainty();
    };

    drawUncertainty();
})();

        (() => {
    const ctx = getCanvasContext("waveCollapseCanvas");
    let collapsed = false;

    function drawWave() {
        if (!ctx) return;
        ctx.clearRect(0, 0, 400, 200);
        ctx.strokeStyle = "cyan";
        ctx.lineWidth = 2;

        ctx.beginPath();
        for (let x = 0; x < 400; x++) {
            let y = 100 + Math.sin(x * 0.1) * 50;
            ctx.lineTo(x, y);
        }
        ctx.stroke();
    }

    function collapseWave() {
        if (!ctx) return;
        collapsed = true;
        ctx.clearRect(0, 0, 400, 200);
        ctx.fillStyle = "red";

        ctx.beginPath();
        ctx.arc(200, 100, 50, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "white";
        ctx.font = "20px Arial";
        ctx.fillText("Wave Collapsed!", 140, 180);
    }

    drawWave();
    window.collapseWave = collapseWave;
})();

        (() => {
    const ctx = getCanvasContext("timeReversalCanvas");
    let timeReversed = false;

    function drawTimeFlow() {
        if (!ctx) return;
        ctx.clearRect(0, 0, 400, 200);

        ctx.fillStyle = "blue";
        ctx.beginPath();
        ctx.arc(timeReversed ? 300 : 100, 100, 20, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "white";
        ctx.fillText(timeReversed ? "Past → Future" : "Future → Past", 140, 180);
    }

    window.reverseTime = () => {
        timeReversed = !timeReversed;
        drawTimeFlow();
    };

    drawTimeFlow();
})();

        (() => {
    const ctx = getCanvasContext("eraserCanvas");
    let pathErased = false;

    function drawEraserEffect() {
        if (!ctx) return;
        ctx.clearRect(0, 0, 400, 200);

        if (pathErased) {
            for (let i = 0; i < 400; i += 10) {
                const intensity = Math.sin(i * 0.1) ** 2 * 255;
                ctx.fillStyle = `rgb(${intensity}, ${intensity}, ${intensity})`;
                ctx.fillRect(i, 0, 10, 200);
            }
        } else {
            ctx.fillStyle = "blue";
            for (let i = 0; i < 50; i++) {
                const x = Math.random() * 400;
                const y = Math.random() * 200;
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        ctx.fillStyle = "white";
        ctx.fillText(pathErased ? "Interference Restored" : "Which-Path Known", 120, 180);
    }

    window.erasePath = () => {
        pathErased = !pathErased;
        drawEraserEffect();
    };

    drawEraserEffect();
})();

        (() => {
    const ctx = getCanvasContext("superdeterminismCanvas");
    let outcome = Math.random() > 0.5 ? "Fixed" : "Changeable";

    function drawOutcome() {
        if (!ctx) return;
        ctx.clearRect(0, 0, 400, 200);

        ctx.fillStyle = outcome === "Fixed" ? "red" : "green";
        ctx.beginPath();
        ctx.arc(200, 100, 30, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "white";
        ctx.fillText(`Outcome: ${outcome}`, 140, 180);
    }

    window.changeOutcome = () => {
        if (outcome !== "Fixed") {
            outcome = "Changed!";
        }
        drawOutcome();
    };

    drawOutcome();
})();

        (() => {
    const ctx = getCanvasContext("virtualParticlesCanvas");

    function drawVirtualParticles() {
        if (!ctx) return;
        ctx.clearRect(0, 0, 400, 200);
        
        for (let i = 0; i < 30; i++) {
            const x = Math.random() * 400;
            const y = Math.random() * 200;
            const size = Math.random() * 5;
            
            ctx.fillStyle = `rgba(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255}, 0.8)`;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
        }
        
        requestAnimationFrame(drawVirtualParticles);
    }

    drawVirtualParticles();
})();

        (() => {
    const ctx = getCanvasContext("multiverseSplitCanvas");
    let branches = 0;

    function drawMultiverse() {
        if (!ctx) return;
        ctx.clearRect(0, 0, 400, 200);

        ctx.fillStyle = "white";
        ctx.fillText("Branches: " + branches, 150, 180);
        
        for (let i = 0; i < branches; i++) {
            const x = 200 + (i % 2 === 0 ? i * 10 : -i * 10);
            const y = 100 + (i * 5);
            ctx.fillStyle = i % 2 === 0 ? "blue" : "red";
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    window.splitMultiverse = () => {
        branches += 1;
        drawMultiverse();
    };

    drawMultiverse();
})();

        // 🌌 Quantum Eraser Experiment (Click to change)
(() => {
    const canvas = document.getElementById("quantumEraserCanvas");
    const ctx = canvas.getContext("2d");
    let observerPresent = false;

    function drawInterference() {
        ctx.clearRect(0, 0, 400, 200);
        for (let i = 0; i < 400; i += 10) {
            const intensity = Math.sin(i * 0.1) ** 2 * 255;
            ctx.fillStyle = `rgb(${intensity}, ${intensity}, ${intensity})`;
            ctx.fillRect(i, 0, 10, 200);
        }
    }

    function drawParticles() {
        ctx.clearRect(0, 0, 400, 200);
        ctx.fillStyle = "blue";
        for (let i = 0; i < 100; i++) {
            const x = Math.random() * 400;
            const y = Math.random() * 200;
            ctx.beginPath();
            ctx.arc(x, y, 2, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    function animate() {
        observerPresent ? drawParticles() : drawInterference();
        requestAnimationFrame(animate);
    }

    canvas.addEventListener("click", () => {
        observerPresent = !observerPresent;
    });

    animate();
})();

// 🚀 Quantum Wormhole Simulator (Click to distort)
(() => {
    const canvas = document.getElementById("wormholeCanvas");
    const ctx = canvas.getContext("2d");
    let distortion = 0;

    function drawWormhole() {
        ctx.clearRect(0, 0, 400, 200);
        const gradient = ctx.createRadialGradient(200, 100, 10, 200, 100, 80 + distortion);
        gradient.addColorStop(0, "black");
        gradient.addColorStop(1, "purple");

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(200, 100, 80 + distortion, 0, Math.PI * 2);
        ctx.fill();
    }

    canvas.addEventListener("mousemove", (event) => {
        distortion = Math.sin(event.clientX * 0.01) * 10;
        drawWormhole();
    });

    drawWormhole();
})();

// 🌀 Quantum Fractal Generator (Click to generate)
(() => {
    const canvas = document.getElementById("fractalCanvas");
    const ctx = canvas.getContext("2d");

    function drawFractal(x, y, size, depth) {
        if (depth > 5) return;
        ctx.strokeStyle = `hsl(${Math.random() * 360}, 100%, 50%)`;
        ctx.lineWidth = 2;

        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + size, y - size);
        ctx.stroke();

        drawFractal(x + size, y - size, size * 0.7, depth + 1);
        drawFractal(x - size, y - size, size * 0.7, depth + 1);
    }

    canvas.addEventListener("click", () => {
        ctx.clearRect(0, 0, 400, 200);
        drawFractal(200, 180, 50, 0);
    });

    drawFractal(200, 180, 50, 0);
})();

// ⚡ Quantum Energy Field Distortion (Always visible, reacts to mouse)
(() => {
    const canvas = document.getElementById("energyFieldCanvas");
    const ctx = canvas.getContext("2d");

    function drawEnergyField(x, y) {
        ctx.clearRect(0, 0, 400, 200);
        for (let i = 0; i < 100; i++) {
            const randomX = Math.random() * 400;
            const randomY = Math.random() * 200;
            ctx.fillStyle = `rgba(0, 255, 255, 0.5)`;
            ctx.beginPath();
            ctx.arc(randomX, randomY, 3, 0, Math.PI * 2);
            ctx.fill();
        }

        // Distortion effect at cursor
        ctx.fillStyle = "rgba(255, 0, 0, 0.8)";
        ctx.beginPath();
        ctx.arc(x, y, 15, 0, Math.PI * 2);
        ctx.fill();
    }

    canvas.addEventListener("mousemove", (event) => {
        const rect = canvas.getBoundingClientRect();
        drawEnergyField(event.clientX - rect.left, event.clientY - rect.top);
    });

    drawEnergyField(200, 100);
})();

// 🕳️ Quantum Gravity Well (Click to spawn particles)
(() => {
    const canvas = document.getElementById("gravityWellCanvas");
    const ctx = canvas.getContext("2d");
    let particles = [];

    function drawGravityWell() {
        ctx.clearRect(0, 0, 400, 200);

        // Draw black hole
        ctx.fillStyle = "black";
        ctx.beginPath();
        ctx.arc(200, 100, 80, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = "white";
        for (let i = 1; i < 10; i++) {
            ctx.beginPath();
            ctx.arc(200, 100, 80 + i * 5, 0, Math.PI * 2);
            ctx.stroke();
        }

        // Draw particles falling into the black hole
        particles.forEach((p, index) => {
            p.y += p.vy;
            p.vy *= 0.98; // Slow down
            p.vy += 0.1; // Simulate gravity
            p.x += (200 - p.x) * 0.02; // Pull towards center

            ctx.fillStyle = "yellow";
            ctx.beginPath();
            ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
            ctx.fill();

            if (p.y > 120) particles.splice(index, 1); // Remove when inside black hole
        });

        requestAnimationFrame(drawGravityWell);
    }

    canvas.addEventListener("click", (event) => {
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        particles.push({ x, y, vy: -2 });
    });

    drawGravityWell();
})();
        
(() => {
    const canvas = document.getElementById("timeDistortionCanvas");
    const ctx = canvas.getContext("2d");
    const speedControl = document.getElementById("timeSpeed");
    let timeSpeed = 1;
    let time = 0;

    speedControl.addEventListener("input", (e) => {
        timeSpeed = parseFloat(e.target.value);
    });

    function drawTimeDistortion() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        time += timeSpeed * 0.1;

        // Redshift/Blueshift Effect
        const color = timeSpeed > 0 ? `rgb(255, ${255 - timeSpeed * 50}, ${255 - timeSpeed * 50})` : 
                                      `rgb(${255 + timeSpeed * 50}, 255, 255)`;

        ctx.fillStyle = color;
        ctx.font = "20px Arial";
        ctx.fillText(`Time Flow: ${timeSpeed.toFixed(2)}`, 100, 100);

        // Time Bubble Effect
        ctx.strokeStyle = color;
        ctx.beginPath();
        ctx.arc(200, 100, Math.abs(timeSpeed) * 30, 0, Math.PI * 2);
        ctx.stroke();

        requestAnimationFrame(drawTimeDistortion);
    }
    
    drawTimeDistortion();
})();

        (() => {
    const canvas = document.getElementById("wormholeCanvas");
    const ctx = canvas.getContext("2d");
    let wormholeX = 200;
    let wormholeY = 100;

    canvas.addEventListener("mousemove", (e) => {
        wormholeX = e.offsetX;
        wormholeY = e.offsetY;
    });

    function drawWormhole() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Wormhole Event Horizon
        ctx.fillStyle = "black";
        ctx.beginPath();
        ctx.arc(wormholeX, wormholeY, 30, 0, Math.PI * 2);
        ctx.fill();

        // Glowing Effect
        ctx.strokeStyle = `rgba(0, 255, 255, ${Math.sin(Date.now() * 0.005)})`;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(wormholeX, wormholeY, 35, 0, Math.PI * 2);
        ctx.stroke();

        requestAnimationFrame(drawWormhole);
    }

    drawWormhole();
})();
        (() => {
    const canvas = document.getElementById("realitySplitterCanvas");
    const ctx = canvas.getContext("2d");
    let particles = [{ x: 200, y: 100, dx: 2, dy: 2 }];

    canvas.addEventListener("click", () => {
        particles = particles.flatMap(p => [
            { ...p, dx: p.dx + Math.random() * 2 - 1 },
            { ...p, dy: p.dy + Math.random() * 2 - 1 }
        ]);
    });

    function drawRealitySplit() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        particles.forEach(p => {
            p.x += p.dx;
            p.y += p.dy;
            ctx.fillStyle = `rgba(0, 255, 0, ${Math.random()})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
            ctx.fill();
        });

        requestAnimationFrame(drawRealitySplit);
    }

    drawRealitySplit();
})();
        (() => {
    const canvas = document.getElementById("chaosCanvas");
    const ctx = canvas.getContext("2d");
    let particles = Array.from({ length: 50 }, () => ({
        x: Math.random() * 400,
        y: Math.random() * 200,
        dx: (Math.random() - 0.5) * 4,
        dy: (Math.random() - 0.5) * 4
    }));

    canvas.addEventListener("click", (e) => {
        particles.push({ x: e.offsetX, y: e.offsetY, dx: Math.random() * 4, dy: Math.random() * 4 });
    });

    function drawChaos() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        particles.forEach(p => {
            p.x += p.dx;
            p.y += p.dy;
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
            ctx.fill();
        });

        requestAnimationFrame(drawChaos);
    }

    drawChaos();
})();
        // Ensure the canvas elements exist before running
function getCanvasContext(canvasId) {
    const canvas = document.getElementById(canvasId);
    return canvas ? canvas.getContext("2d") : null;
}

/* =========================== Quantum Time Distortion =========================== */
(() => {
    const ctx = getCanvasContext("timeDistortionCanvas");
    const slider = document.getElementById("timeSpeed");
    let timeFactor = 1;

    slider.addEventListener("input", () => {
        timeFactor = parseFloat(slider.value);
    });

    function drawTimeDistortion() {
        if (!ctx) return;
        ctx.clearRect(0, 0, 400, 200);
        ctx.strokeStyle = "lime";
        for (let i = 0; i < 400; i += 10) {
            const y = 100 + Math.sin((i + Date.now() * timeFactor * 0.01) * 0.1) * 40;
            ctx.beginPath();
            ctx.arc(i, y, 3, 0, Math.PI * 2);
            ctx.stroke();
        }
        requestAnimationFrame(drawTimeDistortion);
    }
    drawTimeDistortion();
})();

/* =========================== Quantum Wormhole Generator =========================== */
(() => {
    const ctx = getCanvasContext("wormholeCanvas");
    let angle = 0;

    function drawWormhole() {
        if (!ctx) return;
        ctx.clearRect(0, 0, 400, 200);
        ctx.strokeStyle = "purple";
        ctx.lineWidth = 3;
        for (let i = 0; i < 20; i++) {
            ctx.beginPath();
            const x = 200 + Math.cos(angle + i * 0.2) * (i * 5);
            const y = 100 + Math.sin(angle + i * 0.2) * (i * 5);
            ctx.arc(x, y, 5, 0, Math.PI * 2);
            ctx.stroke();
        }
        angle += 0.1;
        requestAnimationFrame(drawWormhole);
    }
    drawWormhole();
})();

/* =========================== Quantum Reality Splitter =========================== */
(() => {
    const ctx = getCanvasContext("realitySplitterCanvas");

    function drawRealitySplit() {
        if (!ctx) return;
        ctx.clearRect(0, 0, 400, 200);
        ctx.fillStyle = "white";

        for (let i = 0; i < 10; i++) {
            const x = Math.random() * 400;
            const y = Math.random() * 200;
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.fillStyle = "red";
        ctx.font = "20px Arial";
        ctx.fillText("Reality Splitting...", 120, 100);
    }

    window.splitReality = () => {
        drawRealitySplit();
    };
})();

/* =========================== Subatomic Chaos Engine =========================== */
(() => {
    const ctx = getCanvasContext("chaosCanvas");

    function drawChaos() {
        if (!ctx) return;
        ctx.clearRect(0, 0, 400, 200);
        for (let i = 0; i < 100; i++) {
            const x = Math.random() * 400;
            const y = Math.random() * 200;
            const size = Math.random() * 5;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fillStyle = `hsl(${Math.random() * 360}, 100%, 50%)`;
            ctx.fill();
        }
        requestAnimationFrame(drawChaos);
    }
    drawChaos();
})();

/* =========================== Quantum Gravity Well (Black Hole) =========================== */
(() => {
    const ctx = getCanvasContext("gravityWellCanvas");
    let particles = [];

    function createParticle() {
        return {
            x: Math.random() * 400,
            y: Math.random() * 200,
            vx: (Math.random() - 0.5) * 2,
            vy: (Math.random() - 0.5) * 2
        };
    }

    function drawGravityWell() {
        if (!ctx) return;
        ctx.clearRect(0, 0, 400, 200);
        ctx.fillStyle = "black";
        ctx.beginPath();
        ctx.arc(200, 100, 30, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "white";
        particles.forEach(p => {
            p.vx += (200 - p.x) * 0.001;
            p.vy += (100 - p.y) * 0.001;
            p.x += p.vx;
            p.y += p.vy;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
            ctx.fill();
        });

        requestAnimationFrame(drawGravityWell);
    }

    for (let i = 0; i < 50; i++) particles.push(createParticle());
    drawGravityWell();
})();

// Ensure the canvas elements exist before running
function getCanvasContext(canvasId) {
    const canvas = document.getElementById(canvasId);
    return canvas ? canvas.getContext("2d") : null;
}

/* =========================== Quantum Storm (Charged Particle Chaos) =========================== */
(() => {
    const ctx = getCanvasContext("quantumStormCanvas");
    let particles = Array.from({ length: 100 }, () => ({
        x: Math.random() * 400,
        y: Math.random() * 200,
        vx: (Math.random() - 0.5) * 2,
        vy: (Math.random() - 0.5) * 2,
        charge: Math.random() > 0.5 ? 1 : -1
    }));

    function drawQuantumStorm() {
        if (!ctx) return;
        ctx.clearRect(0, 0, 400, 200);

        particles.forEach(p => {
            p.x += p.vx;
            p.y += p.vy;
            if (p.x < 0 || p.x > 400) p.vx *= -1;
            if (p.y < 0 || p.y > 200) p.vy *= -1;

            ctx.fillStyle = p.charge > 0 ? "cyan" : "magenta";
            ctx.beginPath();
            ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
            ctx.fill();
        });

        requestAnimationFrame(drawQuantumStorm);
    }

    drawQuantumStorm();
})();

/* =========================== Spacetime Ripples (Gravity Waves) =========================== */
(() => {
    const ctx = getCanvasContext("spacetimeRippleCanvas");
    let time = 0;

    function drawRipples() {
        if (!ctx) return;
        ctx.clearRect(0, 0, 400, 200);
        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;

        for (let i = 0; i < 5; i++) {
            let radius = Math.abs(Math.sin(time + i * 0.5)) * 80;
            ctx.beginPath();
            ctx.arc(200, 100, radius, 0, Math.PI * 2);
            ctx.stroke();
        }
        time += 0.05;
        requestAnimationFrame(drawRipples);
    }

    drawRipples();
})();

/* =========================== Dark Matter Field =========================== */
(() => {
    const ctx = getCanvasContext("darkMatterFieldCanvas");
    let particles = Array.from({ length: 50 }, () => ({
        x: Math.random() * 400,
        y: Math.random() * 200,
        vx: (Math.random() - 0.5) * 2,
        vy: (Math.random() - 0.5) * 2,
        alpha: Math.random() * 0.5 + 0.2
    }));

    function drawDarkMatter() {
        if (!ctx) return;
        ctx.clearRect(0, 0, 400, 200);
        ctx.fillStyle = "rgba(128, 0, 128, 0.2)"; // Dark purple

        particles.forEach(p => {
            p.x += p.vx;
            p.y += p.vy;
            if (p.x < 0 || p.x > 400) p.vx *= -1;
            if (p.y < 0 || p.y > 200) p.vy *= -1;

            ctx.beginPath();
            ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(100, 0, 150, ${p.alpha})`;
            ctx.fill();
        });

        requestAnimationFrame(drawDarkMatter);
    }

    drawDarkMatter();
})();

/* =========================== Quantum Flux Field (Reality Distortions) =========================== */
(() => {
    const ctx = getCanvasContext("quantumFluxCanvas");
    let t = 0;

    function drawFluxField() {
        if (!ctx) return;
        ctx.clearRect(0, 0, 400, 200);

        for (let i = 0; i < 100; i++) {
            let x = Math.random() * 400;
            let y = Math.random() * 200;
            let distortion = Math.sin(t + x * 0.01) * 10;
            ctx.fillStyle = `hsl(${(t * 10) % 360}, 100%, 50%)`;
            ctx.fillRect(x + distortion, y, 2, 2);
        }
        t += 0.1;
        requestAnimationFrame(drawFluxField);
    }

    drawFluxField();
})();

/* =========================== Hypercube Portal (Dimensional Rift) =========================== */
(() => {
    const ctx = getCanvasContext("hypercubePortalCanvas");
    let angle = 0;

    function drawHypercube() {
        if (!ctx) return;
        ctx.clearRect(0, 0, 400, 200);

        ctx.strokeStyle = "cyan";
        ctx.lineWidth = 2;

        for (let i = 0; i < 4; i++) {
            let x = 200 + Math.cos(angle + i * Math.PI / 2) * 50;
            let y = 100 + Math.sin(angle + i * Math.PI / 2) * 50;
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, Math.PI * 2);
            ctx.stroke();
        }

        ctx.strokeStyle = "purple";
        for (let i = 0; i < 4; i++) {
            let x = 200 + Math.cos(angle + i * Math.PI / 2 + Math.PI / 4) * 70;
            let y = 100 + Math.sin(angle + i * Math.PI / 2 + Math.PI / 4) * 70;
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, Math.PI * 2);
            ctx.stroke();
        }

        angle += 0.02;
        requestAnimationFrame(drawHypercube);
    }

    drawHypercube();
})();

        /* ---------- Quantum Entropy Cascade ---------- */
(() => {
  const canvas = document.getElementById('entropyCascadeCanvas');
  const ctx = canvas.getContext('2d');
  let particles = [];
  let cascadeActive = false;

  function initParticles() {
    particles = [];
    for (let i = 0; i < 200; i++) {
      particles.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        vx: (Math.random() - 0.5) * 2,
        vy: (Math.random() - 0.5) * 2,
        radius: Math.random() * 3 + 1,
        color: `rgba(255,215,0,${(Math.random() * 0.8 + 0.2).toFixed(2)})`
      });
    }
  }

  function drawEntropy() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    particles.forEach(p => {
      p.x += p.vx;
      p.y += p.vy;
      if (p.x < 0 || p.x > canvas.width) p.vx *= -1;
      if (p.y < 0 || p.y > canvas.height) p.vy *= -1;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
      ctx.fillStyle = p.color;
      ctx.fill();
    });
    if (cascadeActive) requestAnimationFrame(drawEntropy);
  }

  window.triggerEntropyCascade = () => {
    cascadeActive = true;
    initParticles();
    drawEntropy();
  };
})();

/* ---------- Quantum String Symphony ---------- */
(() => {
  const canvas = document.getElementById('stringSymphonyCanvas');
  const ctx = canvas.getContext('2d');
  let animationId;
  let time = 0;

  function drawStrings() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const numStrings = 5;
    for (let i = 0; i < numStrings; i++) {
      ctx.beginPath();
      let startY = (canvas.height / (numStrings + 1)) * (i + 1);
      ctx.moveTo(0, startY);
      for (let x = 0; x < canvas.width; x += 10) {
        let y = startY + Math.sin(x * 0.05 + time + i) * 20;
        ctx.lineTo(x, y);
      }
      ctx.strokeStyle = "#ffd700";
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    time += 0.05;
    animationId = requestAnimationFrame(drawStrings);
  }

  window.startStringSymphony = () => {
    cancelAnimationFrame(animationId);
    time = 0;
    drawStrings();
  };
})();

/* ---------- Quantum Random Walk ---------- */
(() => {
  const canvas = document.getElementById('randomWalkCanvas');
  const ctx = canvas.getContext('2d');
  let x = canvas.width / 2;
  let y = canvas.height / 2;
  let walkActive = false;

  function drawWalk() {
    if (!walkActive) return;
    let stepX = (Math.random() - 0.5) * 20;
    let stepY = (Math.random() - 0.5) * 20;
    x += stepX;
    y += stepY;
    if (x < 0) x = 0;
    if (x > canvas.width) x = canvas.width;
    if (y < 0) y = 0;
    if (y > canvas.height) y = canvas.height;
    ctx.fillStyle = "#ffd700";
    ctx.beginPath();
    ctx.arc(x, y, 3, 0, Math.PI * 2);
    ctx.fill();
    setTimeout(drawWalk, 100);
  }

  window.startRandomWalk = () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    x = canvas.width / 2;
    y = canvas.height / 2;
    walkActive = true;
    drawWalk();
  };
})();

/* ---------- Quantum Phase Transition ---------- */
(() => {
  const canvas = document.getElementById('phaseTransitionCanvas');
  const ctx = canvas.getContext('2d');
  const cols = 10;
  const rows = 5;
  let grid = [];

  function initGrid() {
    grid = [];
    for (let i = 0; i < rows; i++) {
      const row = [];
      for (let j = 0; j < cols; j++) {
        row.push(Math.random() > 0.5 ? 1 : 0);
      }
      grid.push(row);
    }
  }

  function drawGrid() {
    const cellWidth = canvas.width / cols;
    const cellHeight = canvas.height / rows;
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < cols; j++) {
        ctx.fillStyle = grid[i][j] ? "#ffd700" : "#ff0000";
        ctx.fillRect(j * cellWidth, i * cellHeight, cellWidth, cellHeight);
      }
    }
  }

  window.triggerPhaseTransition = () => {
    initGrid();
    let steps = 10;
    const interval = setInterval(() => {
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          if (Math.random() < 0.3) {
            grid[i][j] = grid[i][j] ? 0 : 1;
          }
        }
      }
      drawGrid();
      steps--;
      if (steps <= 0) clearInterval(interval);
    }, 300);
  };
})();

/* ---------- Quantum Bubble Collapse ---------- */
(() => {
  const canvas = document.getElementById('bubbleCollapseCanvas');
  const ctx = canvas.getContext('2d');
  let bubbleRadius = 50;
  let collapsing = false;

  function drawBubble() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = "#ffd700";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(canvas.width / 2, canvas.height / 2, bubbleRadius, 0, Math.PI * 2);
    ctx.stroke();
    if (collapsing) {
      bubbleRadius -= 1;
      if (bubbleRadius > 0) {
        requestAnimationFrame(drawBubble);
      } else {
        // Reset after collapse
        collapsing = false;
        bubbleRadius = 50;
      }
    }
  }

  window.collapseBubble = () => {
    collapsing = true;
    drawBubble();
  };
})();

        /* ===================== Quantum Particle Accelerator ===================== */
const Accelerator = (() => {
  const canvas = document.getElementById("acceleratorCanvas");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");

  // Particle with initial state and trail effect parameters
  let particle = { x: 20, y: canvas.height / 2, vx: 0 };
  let accelerating = false;
  let animationId = null;

  // Draw a semi-transparent overlay to create a fading trail
  const drawTrail = () => {
    ctx.fillStyle = "rgba(0, 0, 0, 0.15)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  };

  // Render the accelerator track and particle
  const draw = () => {
    // Create a trail effect rather than a full clear
    drawTrail();

    // Draw the accelerator track
    ctx.strokeStyle = "#ffd700";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, canvas.height / 2);
    ctx.lineTo(canvas.width, canvas.height / 2);
    ctx.stroke();

    // Draw the particle with a subtle glow
    ctx.beginPath();
    ctx.arc(particle.x, particle.y, 8, 0, Math.PI * 2);
    ctx.fillStyle = "cyan";
    ctx.shadowColor = "#00ffff";
    ctx.shadowBlur = 10;
    ctx.fill();
    ctx.shadowBlur = 0;
  };

  // Animation loop for the accelerator
  const animate = () => {
    if (!accelerating) return;
    // Update physics with constant acceleration
    particle.vx += 0.2;
    particle.x += particle.vx;

    // Bounce off the right edge with energy loss
    if (particle.x > canvas.width - 8) {
      particle.x = canvas.width - 8;
      particle.vx = -particle.vx * 0.5;
    }

    draw();
    animationId = requestAnimationFrame(animate);
  };

  return {
    launchParticle: () => {
      if (!accelerating) {
        accelerating = true;
        animate();
      }
    },
    reset: () => {
      accelerating = false;
      cancelAnimationFrame(animationId);
      particle = { x: 20, y: canvas.height / 2, vx: 0 };
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      draw();
    }
  };
})();


/* ===================== Entangled Particle Dance ===================== */
const EntangledDance = (() => {
  const canvas = document.getElementById("entangledDanceCanvas");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  let dancing = false;
  let animationId = null;
  let time = 0;

  const drawDance = () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    // Calculate offset using sinusoidal functions for an elegant dance
    const offset = Math.sin(time) * 40;
    const verticalOsc = Math.cos(time) * 20;

    // Left particle
    ctx.beginPath();
    ctx.arc(centerX - offset, centerY + verticalOsc, 10, 0, Math.PI * 2);
    ctx.fillStyle = "#00ff00";
    ctx.fill();
    // Right particle (mirror image)
    ctx.beginPath();
    ctx.arc(centerX + offset, centerY - verticalOsc, 10, 0, Math.PI * 2);
    ctx.fillStyle = "#ff00ff";
    ctx.fill();

    // Optional: Display state information
    ctx.fillStyle = "#ffd700";
    ctx.font = "14px Raleway";
    ctx.fillText("Entangled", centerX - 30, canvas.height - 10);

    time += 0.05;
    if (dancing) animationId = requestAnimationFrame(drawDance);
  };

  return {
    toggle: () => {
      dancing = !dancing;
      if (dancing) drawDance();
      else cancelAnimationFrame(animationId);
    }
  };
})();


/* ===================== Chaotic Quantum Collider ===================== */
const Collider = (() => {
  const canvas = document.getElementById("colliderCanvas");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  let particles = [];

  // Particle object with basic physics and collision response
  class Particle {
    constructor(x, y) {
      this.x = x || Math.random() * canvas.width;
      this.y = y || Math.random() * canvas.height;
      this.vx = (Math.random() - 0.5) * 4;
      this.vy = (Math.random() - 0.5) * 4;
      this.radius = Math.random() * 4 + 2;
      this.baseColor = Math.random() * 360;
      this.color = `hsl(${this.baseColor}, 100%, 50%)`;
    }
    update() {
      this.x += this.vx;
      this.y += this.vy;
      // Bounce off edges
      if (this.x < this.radius || this.x > canvas.width - this.radius) this.vx *= -1;
      if (this.y < this.radius || this.y > canvas.height - this.radius) this.vy *= -1;
    }
    draw() {
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
      ctx.fillStyle = this.color;
      ctx.fill();
    }
  }

  // Check collision between two particles and adjust colors on impact
  const handleCollisions = () => {
    for (let i = 0; i < particles.length; i++) {
      for (let j = i + 1; j < particles.length; j++) {
        const p1 = particles[i];
        const p2 = particles[j];
        const dx = p1.x - p2.x;
        const dy = p1.y - p2.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < p1.radius + p2.radius) {
          // Simple color swap effect on collision
          p1.color = `hsl(${(p1.baseColor + 30) % 360}, 100%, 50%)`;
          p2.color = `hsl(${(p2.baseColor + 30) % 360}, 100%, 50%)`;
          // Optionally, swap velocities for a rudimentary bounce
          [p1.vx, p2.vx] = [p2.vx, p1.vx];
          [p1.vy, p2.vy] = [p2.vy, p1.vy];
        }
      }
    }
  };

  const animate = () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    particles.forEach(p => {
      p.update();
      p.draw();
    });
    handleCollisions();
    requestAnimationFrame(animate);
  };

  // Initialize with a few particles
  for (let i = 0; i < 10; i++) particles.push(new Particle());
  animate();

  return {
    addParticle: () => {
      particles.push(new Particle());
    }
  };
})();


/* ===================== Quantum Field Oscillation ===================== */
const FieldOscillation = (() => {
  const canvas = document.getElementById("fieldOscillationCanvas");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  let amplitude = parseFloat(document.getElementById("fieldAmplitude").value);
  let frequency = parseFloat(document.getElementById("fieldFrequency").value);
  let time = 0;
  let animationId;

  const drawField = () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Create a gradient for a dynamic color effect
    const grad = ctx.createLinearGradient(0, 0, canvas.width, 0);
    grad.addColorStop(0, "#ff0000");
    grad.addColorStop(0.5, "#ffd700");
    grad.addColorStop(1, "#00ff00");
    ctx.strokeStyle = grad;
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let x = 0; x < canvas.width; x++) {
      let y = canvas.height / 2 + amplitude * Math.sin(frequency * x + time);
      x === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    }
    ctx.stroke();
    time += 0.1;
    animationId = requestAnimationFrame(drawField);
  };

  // Start the oscillation on load
  drawField();

  return {
    update: () => {
      amplitude = parseFloat(document.getElementById("fieldAmplitude").value);
      frequency = parseFloat(document.getElementById("fieldFrequency").value);
    }
  };
})();


/* ===================== Wormhole Explorer 2.0 ===================== */
const WormholeExplorer = (() => {
  const canvas = document.getElementById("wormholeExplorerCanvas");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  const baseRadius = 50;
  let distortion = 0;
  let animationId;

  const drawWormhole = () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Create a dynamic radial gradient for the wormhole glow
    const gradient = ctx.createRadialGradient(centerX, centerY, baseRadius, centerX, centerY, baseRadius + distortion);
    gradient.addColorStop(0, "rgba(128,0,128,0.8)");
    gradient.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(centerX, centerY, baseRadius + distortion, 0, Math.PI * 2);
    ctx.fill();

    // Draw the dark inner core for depth
    ctx.beginPath();
    ctx.arc(centerX, centerY, baseRadius, 0, Math.PI * 2);
    ctx.fillStyle = "#000";
    ctx.fill();

    // Create a subtle pulsation effect using a sinusoidal function
    distortion = 10 * Math.abs(Math.sin(Date.now() * 0.002));
    animationId = requestAnimationFrame(drawWormhole);
  };

  // Start the wormhole animation immediately
  drawWormhole();

  return {
    distort: () => {
      // On button click, create a temporary distortion spike
      const original = distortion;
      let t = 0;
      const spike = () => {
        t += 0.1;
        distortion = original + 20 * Math.sin(t * Math.PI);
        if (t < 1) requestAnimationFrame(spike);
      };
      spike();
    }
  };
})();
        /* ===================== Quantum Neural Network Simulator ===================== */
const QuantumNeural = (() => {
  const canvas = document.getElementById("quantumNeuralCanvas");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  const numNodes = 15;
  let nodes = [];
  let active = false;
  let animationId;

  // Create nodes with random positions and a slight oscillation offset
  const initNodes = () => {
    nodes = [];
    for (let i = 0; i < numNodes; i++) {
      nodes.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        baseX: 0,
        baseY: 0,
        phase: Math.random() * Math.PI * 2
      });
      nodes[i].baseX = nodes[i].x;
      nodes[i].baseY = nodes[i].y;
    }
  };

  // Draw nodes and connections with a glowing gradient effect
  const draw = (time) => {
    ctx.fillStyle = "rgba(0,0,0,0.15)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Update node positions with a gentle oscillation
    nodes.forEach((node) => {
      node.x = node.baseX + Math.sin(time + node.phase) * 10;
      node.y = node.baseY + Math.cos(time + node.phase) * 10;
    });

    // Draw connections
    for (let i = 0; i < nodes.length; i++) {
      for (let j = i + 1; j < nodes.length; j++) {
        const dx = nodes[i].x - nodes[j].x;
        const dy = nodes[i].y - nodes[j].y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 100) {
          const alpha = 1 - dist / 100;
          ctx.strokeStyle = `rgba(255,215,0,${alpha.toFixed(2)})`;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(nodes[i].x, nodes[i].y);
          ctx.lineTo(nodes[j].x, nodes[j].y);
          ctx.stroke();
        }
      }
    }

    // Draw nodes with glow
    nodes.forEach((node) => {
      ctx.beginPath();
      ctx.arc(node.x, node.y, 5, 0, Math.PI * 2);
      ctx.fillStyle = "#00ffff";
      ctx.shadowColor = "#00ffff";
      ctx.shadowBlur = 10;
      ctx.fill();
      ctx.shadowBlur = 0;
    });
  };

  const animate = (time) => {
    if (!active) return;
    draw(time * 0.002);
    animationId = requestAnimationFrame(animate);
  };

  return {
    toggle: () => {
      active = !active;
      if (active) {
        initNodes();
        animate(0);
      } else {
        cancelAnimationFrame(animationId);
      }
    }
  };
})();


/* ===================== Multidimensional Quantum Landscape ===================== */
const QuantumLandscape = (() => {
  const canvas = document.getElementById("quantumLandscapeCanvas");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  let viewIndex = 0; // Cycle through different views
  const views = [
    { color1: "#ff0000", color2: "#ffd700", waveFactor: 20 },
    { color1: "#00ff00", color2: "#00ffff", waveFactor: 30 },
    { color1: "#0000ff", color2: "#ff00ff", waveFactor: 15 }
  ];
  let time = 0;
  let animationId;

  const drawLandscape = () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const view = views[viewIndex];
    // Create a linear gradient background that shifts over time
    const grad = ctx.createLinearGradient(0, 0, canvas.width, 0);
    grad.addColorStop(0, view.color1);
    grad.addColorStop(1, view.color2);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw layered sine waves to simulate a multidimensional landscape
    for (let layer = 0; layer < 3; layer++) {
      ctx.beginPath();
      const offset = layer * 20;
      for (let x = 0; x <= canvas.width; x += 5) {
        let y =
          canvas.height / 2 +
          Math.sin((x * 0.02) + time + layer) * view.waveFactor +
          offset;
        x === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      }
      ctx.strokeStyle = `rgba(0, 0, 0, ${0.3 + layer * 0.2})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  };

  const animate = () => {
    time += 0.05;
    drawLandscape();
    animationId = requestAnimationFrame(animate);
  };

  // Start animation immediately
  animate();

  return {
    changeView: () => {
      viewIndex = (viewIndex + 1) % views.length;
    }
  };
})();


/* ===================== Quantum Gravity Ripple Simulator ===================== */
const GravityRipple = (() => {
  const canvas = document.getElementById("gravityRippleCanvas");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  let ripples = [];
  let animationId;
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;

  // Create a new ripple with a timestamp and initial radius
  const addRipple = () => {
    ripples.push({ startTime: Date.now(), radius: 0 });
  };

  const drawRipples = () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const currentTime = Date.now();
    ripples = ripples.filter(ripple => currentTime - ripple.startTime < 3000);
    ripples.forEach(ripple => {
      const elapsed = currentTime - ripple.startTime;
      ripple.radius = elapsed * 0.1;
      const alpha = 1 - elapsed / 3000;
      ctx.beginPath();
      ctx.arc(centerX, centerY, ripple.radius, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(255,215,0,${alpha.toFixed(2)})`;
      ctx.lineWidth = 3;
      ctx.stroke();
    });
  };

  const animate = () => {
    drawRipples();
    animationId = requestAnimationFrame(animate);
  };
  animate();

  return {
    disturb: () => {
      addRipple();
    }
  };
})();


/* ===================== Quantum Entanglement Universe ===================== */
const EntanglementUniverse = (() => {
  const canvas = document.getElementById("entanglementUniverseCanvas");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  const numNodes = 25;
  let nodes = [];
  let animationId;
  let time = 0;

  // Initialize nodes with random positions and velocities
  const init = () => {
    nodes = [];
    for (let i = 0; i < numNodes; i++) {
      nodes.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        vx: (Math.random() - 0.5) * 0.5,
        vy: (Math.random() - 0.5) * 0.5
      });
    }
  };

  const draw = () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Update nodes and draw connections
    nodes.forEach(node => {
      node.x += node.vx;
      node.y += node.vy;
      // Bounce off edges
      if (node.x < 0 || node.x > canvas.width) node.vx *= -1;
      if (node.y < 0 || node.y > canvas.height) node.vy *= -1;
      ctx.beginPath();
      ctx.arc(node.x, node.y, 4, 0, Math.PI * 2);
      ctx.fillStyle = "#ffd700";
      ctx.fill();
    });
    // Draw dynamic connections based on distance
    for (let i = 0; i < nodes.length; i++) {
      for (let j = i + 1; j < nodes.length; j++) {
        const dx = nodes[i].x - nodes[j].x;
        const dy = nodes[i].y - nodes[j].y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 80) {
          const alpha = 1 - dist / 80;
          ctx.strokeStyle = `rgba(0,255,255,${alpha.toFixed(2)})`;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(nodes[i].x, nodes[i].y);
          ctx.lineTo(nodes[j].x, nodes[j].y);
          ctx.stroke();
        }
      }
    }
  };

  const animate = () => {
    time += 0.01;
    draw();
    animationId = requestAnimationFrame(animate);
  };

  // Start simulation immediately
  init();
  animate();

  return {
    shuffle: () => {
      // Randomize node positions
      nodes.forEach(node => {
        node.x = Math.random() * canvas.width;
        node.y = Math.random() * canvas.height;
      });
    }
  };
})();


/* ===================== Spacetime Distortion Portal ===================== */
const DistortionPortal = (() => {
  const canvas = document.getElementById("distortionPortalCanvas");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  const baseRadius = 50;
  let time = 0;
  let warpEffect = 0;
  let animationId;

  const drawPortal = () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Calculate a dynamic distortion factor
    const distortion = baseRadius + warpEffect + 10 * Math.abs(Math.sin(time));
    const gradient = ctx.createRadialGradient(centerX, centerY, baseRadius, centerX, centerY, distortion);
    gradient.addColorStop(0, "rgba(128,0,128,0.8)");
    gradient.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(centerX, centerY, distortion, 0, Math.PI * 2);
    ctx.fill();
    
    // Draw inner core
    ctx.beginPath();
    ctx.arc(centerX, centerY, baseRadius, 0, Math.PI * 2);
    ctx.fillStyle = "#000";
    ctx.fill();
  };

  const animate = () => {
    time += 0.03;
    // Gradually reduce any warp effect over time
    warpEffect *= 0.98;
    drawPortal();
    animationId = requestAnimationFrame(animate);
  };

  animate();

  return {
    warp: () => {
      // On button click, trigger a temporary warp effect
      warpEffect = 30;
    }
  };
})();
        /* ===================== Quantum Tunneling Visualizer ===================== */
const TunnelingVisualizer = (() => {
  const canvas = document.getElementById("tunnelingVisualizerCanvas");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  const barrierHeightSlider = document.getElementById("barrierHeight");
  const barrierWidthSlider = document.getElementById("barrierWidth");
  let particleX = 50;
  const particleY = canvas.height / 2;
  let animationId;
  let simulating = false;

  // Draw the scene: barrier and particle (with glow color changing on success)
  const drawScene = (tunnelSuccess) => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Draw barrier
    const barrierWidth = parseInt(barrierWidthSlider.value);
    const barrierHeight = parseInt(barrierHeightSlider.value);
    const barrierX = canvas.width / 2 - barrierWidth / 2;
    const barrierY = canvas.height / 2 - barrierHeight / 2;
    ctx.fillStyle = "#555";
    ctx.fillRect(barrierX, barrierY, barrierWidth, barrierHeight);
    // Draw particle
    ctx.beginPath();
    ctx.arc(particleX, particleY, 8, 0, Math.PI * 2);
    ctx.fillStyle = tunnelSuccess ? "#00ff00" : "#00ffff";
    ctx.shadowColor = "#00ffff";
    ctx.shadowBlur = 10;
    ctx.fill();
    ctx.shadowBlur = 0;
  };

  // Animate the particle approaching and interacting with the barrier
  const simulate = () => {
    if (simulating) return;
    simulating = true;
    particleX = 50;
    let tunnelSuccess = false;
    const barrierWidth = parseInt(barrierWidthSlider.value);
    const barrierX = canvas.width / 2 - barrierWidth / 2;

    const animate = () => {
      // Move particle toward barrier
      if (particleX < barrierX - 8) {
        particleX += 2;
      } else if (particleX < barrierX + barrierWidth + 8) {
        // In barrier region: decide on tunneling success based on a rough heuristic
        if (!tunnelSuccess) {
          const prob = Math.exp(-((barrierWidth / 50) * (parseInt(barrierHeightSlider.value) / 50)));
          tunnelSuccess = (Math.random() < prob);
        }
        particleX += tunnelSuccess ? 4 : -2;
      } else {
        particleX += 2;
      }
      drawScene(tunnelSuccess);
      if (particleX < canvas.width - 10) {
        animationId = requestAnimationFrame(animate);
      } else {
        simulating = false;
      }
    };
    animate();
  };

  return {
    simulate: simulate
  };
})();


/* ===================== Wave Function Collapse Simulator ===================== */
const CollapseSimulator = (() => {
  const canvas = document.getElementById("collapseSimulatorCanvas");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  let collapsing = false;
  let collapseProgress = 0;
  let animationId;

  // Draw a smooth Gaussian wave function that will collapse when measured
  const drawWaveFunction = () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.beginPath();
    for (let x = 0; x < canvas.width; x++) {
      const norm = (x - canvas.width / 2) / 50;
      // As collapseProgress goes from 0 to 1, the wave function narrows toward a spike
      const amplitude = 40 * (1 - collapseProgress) + 10 * collapseProgress;
      const y = canvas.height / 2 - 40 * Math.exp(-norm * norm) * (1 - collapseProgress) - amplitude * collapseProgress;
      x === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    }
    ctx.strokeStyle = "#00ffff";
    ctx.lineWidth = 2;
    ctx.stroke();
  };

  // Animate the collapse of the wave function over time
  const animateCollapse = () => {
    collapseProgress += 0.02;
    if (collapseProgress > 1) {
      collapseProgress = 0;
      collapsing = false;
      cancelAnimationFrame(animationId);
    } else {
      drawWaveFunction();
      animationId = requestAnimationFrame(animateCollapse);
    }
  };

  return {
    measure: () => {
      if (!collapsing) {
        collapsing = true;
        collapseProgress = 0;
        animateCollapse();
      }
    }
  };
})();


/* ===================== Superposition Decision Tree ===================== */
const SuperpositionTree = (() => {
  const canvas = document.getElementById("superpositionTreeCanvas");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  // Define three possible outcome branches
  const branches = [
    { startX: canvas.width / 2, startY: canvas.height, endX: canvas.width / 4, endY: canvas.height / 2 },
    { startX: canvas.width / 2, startY: canvas.height, endX: canvas.width / 2, endY: canvas.height / 2 },
    { startX: canvas.width / 2, startY: canvas.height, endX: (3 * canvas.width) / 4, endY: canvas.height / 2 }
  ];
  let collapsed = false;
  let chosenIndex = null;

  // Draw the decision tree with branch probabilities
  const drawTree = () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Draw trunk
    ctx.strokeStyle = "#ffd700";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(canvas.width / 2, canvas.height);
    ctx.lineTo(canvas.width / 2, canvas.height - 50);
    ctx.stroke();
    // Draw branches
    branches.forEach((branch, i) => {
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2, canvas.height - 50);
      ctx.lineTo(branch.endX, branch.endY);
      ctx.strokeStyle = (collapsed && chosenIndex === i) ? "#00ff00" : "#ffd700";
      ctx.lineWidth = collapsed && chosenIndex === i ? 6 : 4;
      ctx.stroke();
      // Draw probability label at the midpoint
      ctx.fillStyle = "#00ffff";
      ctx.font = "12px Raleway";
      ctx.fillText(`P=${(1 / branches.length).toFixed(2)}`, (canvas.width / 2 + branch.endX) / 2, (canvas.height - 50 + branch.endY) / 2);
    });
  };

  drawTree();

  return {
    collapse: () => {
      collapsed = true;
      chosenIndex = Math.floor(Math.random() * branches.length);
      drawTree();
      // Reset after 2 seconds
      setTimeout(() => {
        collapsed = false;
        chosenIndex = null;
        drawTree();
      }, 2000);
    }
  };
})();


/* ===================== Decoherence Detector ===================== */
const DecoherenceDetector = (() => {
  const canvas = document.getElementById("decoherenceCanvas");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  const decoherenceSlider = document.getElementById("decoherenceLevel");
  let animationId;
  let time = 0;

  // Draw an interference pattern that gradually degrades with increased decoherence
  const drawInterference = () => {
    const decoherence = parseFloat(decoherenceSlider.value);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let x = 0; x < canvas.width; x += 5) {
      const baseIntensity = (Math.sin(x * 0.05 + time) + 1) / 2;
      // Blend the interference pattern with random noise according to the decoherence level
      const noise = Math.random() * decoherence;
      const finalIntensity = Math.min(1, baseIntensity * (1 - decoherence) + noise);
      ctx.fillStyle = `rgba(255,215,0,${finalIntensity.toFixed(2)})`;
      ctx.fillRect(x, 0, 5, canvas.height);
    }
    time += 0.05;
    animationId = requestAnimationFrame(drawInterference);
  };

  drawInterference();

  return {};
})();


/* ===================== Quantum Time Machine ===================== */
const TimeMachine = (() => {
  const canvas = document.getElementById("timeMachineCanvas");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  const timeSpeedControl = document.getElementById("timeSpeedControl");
  let time = 0;
  let animationId;

  // Draw dynamic radial waves that evolve based on the time speed
  const drawTimePattern = () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const speed = parseFloat(timeSpeedControl.value);
    time += speed * 0.05;
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    for (let i = 0; i < 5; i++) {
      const radius = Math.abs(Math.sin(time + i)) * 40 + 20;
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(0,255,255,${(1 - i * 0.2).toFixed(2)})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    animationId = requestAnimationFrame(drawTimePattern);
  };

  drawTimePattern();

  return {};
})();
        /* ===================== Quantum Multiverse Explorer ===================== */
const Multiverse = (() => {
  const canvas = document.getElementById("multiverseCanvas");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  let universes = [];
  let animationId;
  let splitTrigger = false;

  // Each universe is a swirling vortex represented by a circle with dynamic distortions
  class Universe {
    constructor(x, y, baseRadius, hue) {
      this.x = x;
      this.y = y;
      this.baseRadius = baseRadius;
      this.hue = hue;
      this.distortion = 0;
    }
    update(time) {
      this.distortion = 10 * Math.abs(Math.sin(time * 0.05 + this.hue));
    }
    draw() {
      const radius = this.baseRadius + this.distortion;
      const grad = ctx.createRadialGradient(this.x, this.y, this.baseRadius, this.x, this.y, radius);
      grad.addColorStop(0, `hsla(${this.hue},100%,50%,0.8)`);
      grad.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  const initUniverses = () => {
    universes = [];
    // Start with one central universe
    universes.push(new Universe(canvas.width / 2, canvas.height / 2, 30, 200));
  };

  const animate = (time) => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    universes.forEach(u => {
      u.update(time);
      u.draw();
    });
    if (splitTrigger && universes.length < 20) {
      // Randomly split a universe into two new ones
      const idx = Math.floor(Math.random() * universes.length);
      const parent = universes[idx];
      universes.push(new Universe(
        parent.x + (Math.random() - 0.5) * 40,
        parent.y + (Math.random() - 0.5) * 40,
        parent.baseRadius * 0.8,
        (parent.hue + 30) % 360
      ));
    }
    animationId = requestAnimationFrame(animate);
  };

  // Public API: trigger a split event once per button click
  return {
    split: () => {
      splitTrigger = true;
      // Let the effect run for 1 second then reset trigger
      setTimeout(() => { splitTrigger = false; }, 1000);
      if (universes.length === 0) initUniverses();
    },
    start: () => {
      initUniverses();
      animate(0);
    }
  };
})();
Multiverse.start();


/* ===================== Quantum Entanglement Arena ===================== */
const EntanglementArena = (() => {
  const canvas = document.getElementById("entanglementArenaCanvas");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  let particles = [];
  let battleActive = false;
  let animationId;

  // Particle with entangled partner properties
  class Particle {
    constructor(x, y, vx, vy, color) {
      this.x = x;
      this.y = y;
      this.vx = vx;
      this.vy = vy;
      this.color = color;
    }
    update() {
      this.x += this.vx;
      this.y += this.vy;
      if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
      if (this.y < 0 || this.y > canvas.height) this.vy *= -1;
    }
    draw() {
      ctx.beginPath();
      ctx.arc(this.x, this.y, 6, 0, Math.PI * 2);
      ctx.fillStyle = this.color;
      ctx.fill();
    }
  }

  // Initialize with entangled pairs (particles mirror each other’s motion)
  const initBattle = () => {
    particles = [];
    for (let i = 0; i < 10; i++) {
      const x = Math.random() * canvas.width;
      const y = Math.random() * canvas.height;
      const vx = (Math.random() - 0.5) * 3;
      const vy = (Math.random() - 0.5) * 3;
      particles.push(new Particle(x, y, vx, vy, "#00ffff"));
      // Create its entangled partner mirrored across center
      const mirrorX = canvas.width - x;
      const mirrorY = canvas.height - y;
      particles.push(new Particle(mirrorX, mirrorY, -vx, -vy, "#ff00ff"));
    }
  };

  const animate = () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    particles.forEach(p => {
      p.update();
      p.draw();
    });
    animationId = requestAnimationFrame(animate);
  };

  return {
    battle: () => {
      battleActive = !battleActive;
      if (battleActive) {
        initBattle();
        animate();
      } else {
        cancelAnimationFrame(animationId);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
    }
  };
})();


/* ===================== Decoherence Escape Challenge ===================== */
const DecoherenceEscape = (() => {
  const canvas = document.getElementById("decoherenceEscapeCanvas");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  let coherence = 1.0;
  let escapeActive = false;
  let animationId;

  // Draw an interference pattern that degrades with decoherence
  const drawPattern = () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let x = 0; x < canvas.width; x += 4) {
      let intensity = (Math.sin(x * 0.05) + 1) / 2 * coherence;
      ctx.fillStyle = `rgba(255,215,0,${intensity.toFixed(2)})`;
      ctx.fillRect(x, 0, 4, canvas.height);
    }
  };

  // When the user clicks the button, they "fight" decoherence by boosting coherence
  const activateEscape = () => {
    escapeActive = true;
    const boost = setInterval(() => {
      coherence = Math.min(1.0, coherence + 0.05);
      if (coherence >= 1.0) {
        clearInterval(boost);
        escapeActive = false;
      }
    }, 100);
  };

  const animate = () => {
    // Gradually let decoherence creep in unless resisted
    if (!escapeActive) {
      coherence = Math.max(0, coherence - 0.001);
    }
    drawPattern();
    animationId = requestAnimationFrame(animate);
  };

  animate();

  return {
    activate: activateEscape
  };
})();


/* ===================== Quantum Algorithm Visualizer ===================== */
const QuantumAlgorithm = (() => {
  const canvas = document.getElementById("algorithmCanvas");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  let circuitNodes = [];
  let animationId;
  let running = false;

  // Build a network of nodes representing qubits and gates
  const initCircuit = () => {
    circuitNodes = [];
    const numQubits = 4;
    const numGates = 6;
    for (let q = 0; q < numQubits; q++) {
      for (let g = 0; g < numGates; g++) {
        circuitNodes.push({
          x: 50 + g * 50,
          y: 50 + q * 40,
          active: Math.random() > 0.5
        });
      }
    }
  };

  const drawCircuit = () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    circuitNodes.forEach(node => {
      ctx.beginPath();
      ctx.arc(node.x, node.y, 8, 0, Math.PI * 2);
      ctx.fillStyle = node.active ? "#00ff00" : "#ff0000";
      ctx.fill();
    });
    // Draw connections (gates influence nearby nodes)
    for (let i = 0; i < circuitNodes.length; i++) {
      for (let j = i + 1; j < circuitNodes.length; j++) {
        const dx = circuitNodes[i].x - circuitNodes[j].x;
        const dy = circuitNodes[i].y - circuitNodes[j].y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 60) {
          ctx.strokeStyle = "rgba(255,215,0,0.5)";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(circuitNodes[i].x, circuitNodes[i].y);
          ctx.lineTo(circuitNodes[j].x, circuitNodes[j].y);
          ctx.stroke();
        }
      }
    }
  };

  const animate = () => {
    // Randomly toggle nodes to simulate algorithm evolution
    circuitNodes.forEach(node => {
      if (Math.random() < 0.02) {
        node.active = !node.active;
      }
    });
    drawCircuit();
    animationId = requestAnimationFrame(animate);
  };

  return {
    run: () => {
      if (!running) {
        initCircuit();
        running = true;
        animate();
      }
    }
  };
})();


/* ===================== Quantum Black Hole Playground ===================== */
const BlackHole = (() => {
  const canvas = document.getElementById("blackHoleCanvas");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  let particles = [];
  let warpActive = false;
  let animationId;

  // Create swirling particles around the black hole
  class SpaceParticle {
    constructor() {
      this.x = canvas.width / 2 + (Math.random() - 0.5) * 200;
      this.y = canvas.height / 2 + (Math.random() - 0.5) * 200;
      this.vx = (Math.random() - 0.5) * 1;
      this.vy = (Math.random() - 0.5) * 1;
      this.size = Math.random() * 3 + 1;
    }
    update() {
      // Gravitation pull towards center
      const dx = canvas.width / 2 - this.x;
      const dy = canvas.height / 2 - this.y;
      this.vx += dx * 0.0005;
      this.vy += dy * 0.0005;
      // If warp is active, add extra random distortion
      if (warpActive) {
        this.vx += (Math.random() - 0.5) * 0.5;
        this.vy += (Math.random() - 0.5) * 0.5;
      }
      this.x += this.vx;
      this.y += this.vy;
    }
    draw() {
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
      ctx.fillStyle = "#ffffff";
      ctx.fill();
    }
  }

  const initParticles = () => {
    particles = [];
    for (let i = 0; i < 100; i++) {
      particles.push(new SpaceParticle());
    }
  };

  const drawBlackHole = () => {
    // Draw black hole core
    ctx.beginPath();
    ctx.arc(canvas.width / 2, canvas.height / 2, 30, 0, Math.PI * 2);
    ctx.fillStyle = "#000";
    ctx.fill();
    // Draw swirling accretion disk
    const grad = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 30, canvas.width/2, canvas.height/2, 80);
    grad.addColorStop(0, "rgba(255,140,0,0.8)");
    grad.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(canvas.width / 2, canvas.height / 2, 80, 0, Math.PI * 2);
    ctx.fill();
  };

  const animate = () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawBlackHole();
    particles.forEach(p => {
      p.update();
      p.draw();
    });
    animationId = requestAnimationFrame(animate);
  };

  initParticles();
  animate();

  return {
    warp: () => {
      warpActive = true;
      // Activate warp for 1 second
      setTimeout(() => { warpActive = false; }, 1000);
    }
  };
})();
        /* ===================== Quantum Reality Synthesizer ===================== */
/*
  Generates fractal-like patterns on canvas by recursively drawing branches.
  The “synthDepth” slider controls the recursion depth (complexity).
*/
const RealitySynthesizer = (() => {
  const canvas = document.getElementById("realitySynthCanvas");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  const depthSlider = document.getElementById("synthDepth");

  // Recursive fractal branch drawing function
  function drawBranch(x, y, angle, length, depth) {
    if (depth === 0 || length < 2) return;
    const rad = angle * Math.PI / 180;
    const xEnd = x + length * Math.cos(rad);
    const yEnd = y + length * Math.sin(rad);
    
    // Set stroke style with glow
    ctx.strokeStyle = `hsla(${(depth*36) % 360}, 100%, 50%, 0.8)`;
    ctx.lineWidth = depth;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(xEnd, yEnd);
    ctx.stroke();

    // Recursive calls for two branches with random variation
    const newLength = length * (0.7 + Math.random() * 0.1);
    drawBranch(xEnd, yEnd, angle - (15 + Math.random() * 10), newLength, depth - 1);
    drawBranch(xEnd, yEnd, angle + (15 + Math.random() * 10), newLength, depth - 1);
  }

  function generate() {
    // Clear canvas and set black background
    ctx.fillStyle = "rgba(0, 0, 0, 0.15)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    const depth = parseInt(depthSlider.value);
    // Draw fractal starting from center bottom
    drawBranch(canvas.width / 2, canvas.height, -90, 60, depth);
  }

  return { generate };
})();


/* ===================== Quantum Entropy Reactor ===================== */
/*
  Simulates a reactor of thousands of micro-particles whose collective entropy 
  can be “ignited” to cause an explosive, chaotic effect.
*/
const EntropyReactor = (() => {
  const canvas = document.getElementById("entropyReactorCanvas");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  let particles = [];
  let ignition = false;
  let animationId;

  // Initialize particles with random positions and velocities
  function initParticles() {
    particles = [];
    for (let i = 0; i < 300; i++) {
      particles.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        vx: (Math.random() - 0.5) * 1,
        vy: (Math.random() - 0.5) * 1,
        radius: Math.random() * 2 + 1,
        color: `rgba(255,215,0,${(Math.random() * 0.5 + 0.5).toFixed(2)})`
      });
    }
  }

  function updateParticles() {
    particles.forEach(p => {
      // When ignition is active, particles accelerate chaotically
      if (ignition) {
        p.vx += (Math.random() - 0.5) * 0.5;
        p.vy += (Math.random() - 0.5) * 0.5;
      }
      p.x += p.vx;
      p.y += p.vy;
      // Wrap-around boundaries
      if (p.x < 0) p.x += canvas.width;
      if (p.x > canvas.width) p.x -= canvas.width;
      if (p.y < 0) p.y += canvas.height;
      if (p.y > canvas.height) p.y -= canvas.height;
    });
  }

  function drawParticles() {
    // Use a slight trail effect
    ctx.fillStyle = "rgba(0, 0, 0, 0.2)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    particles.forEach(p => {
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
      ctx.fillStyle = p.color;
      ctx.fill();
    });
  }

  function animate() {
    updateParticles();
    drawParticles();
    animationId = requestAnimationFrame(animate);
  }

  // Start continuous animation
  initParticles();
  animate();

  return {
    ignite: () => {
      ignition = true;
      // Ignite for 2 seconds then let entropy settle
      setTimeout(() => { ignition = false; }, 2000);
    }
  };
})();


/* ===================== Quantum Field Collider ===================== */
/*
  Simulates two opposing quantum fields that collide and create a dramatic 
  interference pattern. The collision is triggered on demand.
*/
const FieldCollider = (() => {
  const canvas = document.getElementById("fieldColliderCanvas");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  let time = 0;
  let collisionActive = false;
  let animationId;

  function drawField() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Create two sine-wave fields from left and right
    for (let x = 0; x < canvas.width; x += 2) {
      let y1 = canvas.height / 2 + 30 * Math.sin(0.02 * x + time);
      let y2 = canvas.height / 2 - 30 * Math.sin(0.02 * (canvas.width - x) + time);
      // Draw interference lines where they overlap
      ctx.fillStyle = "rgba(0,255,255,0.7)";
      ctx.fillRect(x, (y1 + y2) / 2, 2, 2);
    }
    time += 0.05;
  }

  function animate() {
    drawField();
    if (collisionActive) {
      // Intensify interference for a brief moment
      ctx.globalCompositeOperation = "lighter";
    } else {
      ctx.globalCompositeOperation = "source-over";
    }
    animationId = requestAnimationFrame(animate);
  }

  // Start continuous animation
  animate();

  return {
    collide: () => {
      collisionActive = true;
      // Activate collision effect for 1.5 seconds
      setTimeout(() => { collisionActive = false; }, 1500);
    }
  };
})();


/* ===================== Quantum Superposition Maze ===================== */
/*
  Presents a dynamic maze where multiple potential paths exist simultaneously.
  On pressing “Start Maze,” a random path is “collapsed” and highlighted.
*/
const SuperpositionMaze = (() => {
  const canvas = document.getElementById("superpositionMazeCanvas");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  let maze;
  let solutionPath = [];

  // Generate a simple randomized maze grid
  function generateMaze(rows, cols) {
    // Create a 2D grid with random walls (0: open, 1: wall)
    const grid = [];
    for (let r = 0; r < rows; r++) {
      grid[r] = [];
      for (let c = 0; c < cols; c++) {
        grid[r][c] = Math.random() < 0.3 ? 1 : 0;
      }
    }
    // Ensure entrance and exit are open
    grid[0][0] = 0;
    grid[rows - 1][cols - 1] = 0;
    return grid;
  }

  // Simple maze solver that picks one random valid path (superposition collapse)
  function solveMaze(grid) {
    const rows = grid.length;
    const cols = grid[0].length;
    const path = [];
    let r = 0, c = 0;
    path.push({ r, c });
    while (!(r === rows - 1 && c === cols - 1)) {
      const moves = [];
      if (r < rows - 1 && grid[r + 1][c] === 0) moves.push({ r: r + 1, c });
      if (c < cols - 1 && grid[r][c + 1] === 0) moves.push({ r, c: c + 1 });
      if (moves.length === 0) break;
      const move = moves[Math.floor(Math.random() * moves.length)];
      r = move.r;
      c = move.c;
      path.push({ r, c });
    }
    return path;
  }

  function drawMaze(grid, path) {
    const rows = grid.length;
    const cols = grid[0].length;
    const cellW = canvas.width / cols;
    const cellH = canvas.height / rows;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Draw maze grid
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        ctx.fillStyle = grid[r][c] === 1 ? "#222" : "#000";
        ctx.fillRect(c * cellW, r * cellH, cellW, cellH);
      }
    }
    // Highlight the collapsed solution path
    ctx.fillStyle = "rgba(0,255,0,0.5)";
    path.forEach(({ r, c }) => {
      ctx.fillRect(c * cellW, r * cellH, cellW, cellH);
    });
  }

  return {
    start: () => {
      const rows = 10, cols = 15;
      maze = generateMaze(rows, cols);
      solutionPath = solveMaze(maze);
      drawMaze(maze, solutionPath);
    }
  };
})();


/* ===================== Quantum Wormhole Architect ===================== */
/*
  Allows users to design a wormhole by adjusting warp intensity.
  The wormhole is rendered as a swirling radial gradient that distorts dynamically.
*/
const WormholeArchitect = (() => {
  const canvas = document.getElementById("wormholeArchitectCanvas");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  const intensitySlider = document.getElementById("warpIntensity");
  let time = 0;
  let animationId;

  function drawWormhole() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const warp = parseInt(intensitySlider.value);
    // Dynamic distortion using time and warp intensity
    const radius = 50 + warp * Math.abs(Math.sin(time * 0.1));
    const gradient = ctx.createRadialGradient(centerX, centerY, 50, centerX, centerY, radius);
    gradient.addColorStop(0, "rgba(128,0,128,0.8)");
    gradient.addColorStop(0.7, "rgba(0,0,0,0.5)");
    gradient.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
    ctx.fill();

    // Optional: add swirling particle effects
    for (let i = 0; i < 30; i++) {
      const angle = Math.random() * Math.PI * 2;
      const r = radius + Math.random() * 20;
      const x = centerX + r * Math.cos(angle + time * 0.2);
      const y = centerY + r * Math.sin(angle + time * 0.2);
      ctx.beginPath();
      ctx.arc(x, y, 2, 0, Math.PI * 2);
      ctx.fillStyle = "#ffd700";
      ctx.fill();
    }
    time += 0.05;
    animationId = requestAnimationFrame(drawWormhole);
  }

  // Start continuous animation
  drawWormhole();

  return {
    build: () => {
      // On button press, momentarily increase warp intensity
      const original = parseInt(intensitySlider.value);
      intensitySlider.value = original * 1.5;
      setTimeout(() => { intensitySlider.value = original; }, 1000);
    }
  };
})();






        

    </script>

    


</body>
</html>
